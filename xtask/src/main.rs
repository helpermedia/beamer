//! Build tooling for Beamer plugins.
//!
//! Usage: cargo xtask bundle <package> [--vst3] [--auv2] [--auv3] [--arch <arch>] [--release] [--install] [--clean]

use std::fs;
use std::io::IsTerminal;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Print an error message, with red color if stderr is a terminal.
fn print_error(msg: &str) {
    if std::io::stderr().is_terminal() {
        eprintln!("\x1b[1;31mError:\x1b[0m {}", msg);
    } else {
        eprintln!("Error: {}", msg);
    }
}

/// Print status message (always shown)
macro_rules! status {
    ($($arg:tt)*) => {
        println!($($arg)*)
    };
}

/// Print verbose message (only in verbose mode)
macro_rules! verbose {
    ($verbose:expr, $($arg:tt)*) => {
        if $verbose {
            println!($($arg)*)
        }
    };
}

/// Shorten home directory in path for display
fn shorten_path(path: &Path) -> String {
    if let Some(home) = std::env::var_os("HOME") {
        let home_path = PathBuf::from(home);
        if let Ok(stripped) = path.strip_prefix(&home_path) {
            return format!("~/{}", stripped.display());
        }
    }
    path.display().to_string()
}

/// Architecture configuration for builds
#[derive(Debug, Clone, Copy, PartialEq)]
enum Arch {
    /// Build for current machine's architecture only
    Native,
    /// Build universal binary (x86_64 + arm64)
    Universal,
    /// Build for arm64 only
    Arm64,
    /// Build for x86_64 only
    X86_64,
}

impl Arch {
    fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "native" => Some(Arch::Native),
            "universal" => Some(Arch::Universal),
            "arm64" | "aarch64" => Some(Arch::Arm64),
            "x86_64" | "x86-64" | "intel" => Some(Arch::X86_64),
            _ => None,
        }
    }
}

/// Configuration for creating appex Info.plist (AUv3)
struct AppexPlistConfig<'a> {
    package: &'a str,
    executable_name: &'a str,
    component_type: &'a str,
    manufacturer: Option<&'a str>,
    subtype: Option<&'a str>,
    framework_bundle_id: &'a str,
    version_string: &'a str,
    version_int: u32,
    plugin_name: Option<&'a str>,
    vendor_name: Option<&'a str>,
}

/// Configuration for creating AUv2 component Info.plist
struct ComponentPlistConfig<'a> {
    package: &'a str,
    executable_name: &'a str,
    component_type: &'a str,
    manufacturer: Option<&'a str>,
    subtype: Option<&'a str>,
    version_string: &'a str,
    version_int: u32,
    plugin_name: Option<&'a str>,
    vendor_name: Option<&'a str>,
}

/// Configuration for the bundle command
struct BundleConfig {
    package: String,
    release: bool,
    install: bool,
    clean: bool,
    build_vst3: bool,
    build_auv2: bool,
    build_auv3: bool,
    arch: Arch,
    verbose: bool,
}

// =============================================================================
// ObjC Code Generation
// =============================================================================

/// Convert plugin name to PascalCase for class names.
/// "midi-transform" â†’ "MidiTransform"
fn to_pascal_case(name: &str) -> String {
    name.split(['-', '_'])
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

/// Generate the AU wrapper ObjC implementation with plugin-specific class names.
fn generate_au_wrapper_source(plugin_name: &str) -> String {
    let pascal_name = to_pascal_case(plugin_name);
    let wrapper_class = format!("Beamer{}AuWrapper", pascal_name);

    format!(r#"// Auto-generated AU wrapper for {plugin_name}
// DO NOT EDIT - Generated by xtask

#import <AudioToolbox/AudioToolbox.h>
#import <AVFoundation/AVFoundation.h>
#import <Foundation/Foundation.h>
#include <os/lock.h>
#include <os/log.h>

#include "BeamerAuBridge.h"

// =============================================================================
// MARK: - Constants
// =============================================================================

static const double kDefaultSampleRate = 44100.0;
static const AUAudioFrameCount kDefaultMaxFrames = 4096;

// =============================================================================
// MARK: - {wrapper_class} Interface
// =============================================================================

@interface {wrapper_class} : AUAudioUnit {{
    BeamerAuInstanceHandle _rustInstance;
    NSLock* _instanceLock;
    BOOL _instanceValid;
    AUParameterTree* _parameterTree;
    BeamerAuSampleFormat _sampleFormat;
    double _sampleRate;
    AUAudioFrameCount _maxFrames;
    BOOL _resourcesAllocated;
    BeamerAuBusConfig _busConfig;
    NSUInteger _instanceId;
    AVAudioPCMBuffer* _inputPCMBuffer;
    AudioBufferList* _inputMutableABL;
    AUAudioUnitPreset* _currentPreset;
    AUInternalRenderBlock _cachedInternalRenderBlock;
    NSArray<AUAudioUnitPreset*>* _factoryPresets;
}}

+ (NSUInteger)nextInstanceId;

@end

// Class extension with bus array properties.
// Using @property enables KVO which AU hosts rely on for bus configuration changes.
@interface {wrapper_class} ()
@property (nonatomic) AUAudioUnitBusArray* inputBusArray;
@property (nonatomic) AUAudioUnitBusArray* outputBusArray;
@end

static NSUInteger {wrapper_class}InstanceCounter = 0;

// =============================================================================
// MARK: - {wrapper_class} Implementation
// =============================================================================

@implementation {wrapper_class}

@synthesize parameterTree = _parameterTree;
@synthesize factoryPresets = _factoryPresets;
@synthesize inputBusArray = _inputBusArray;
@synthesize outputBusArray = _outputBusArray;

+ (NSUInteger)nextInstanceId {{
    @synchronized([{wrapper_class} class]) {{
        return ++{wrapper_class}InstanceCounter;
    }}
}}

- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError {{
    NSUInteger instanceId = [[self class] nextInstanceId];

    if (!beamer_au_ensure_factory_registered()) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FailedInitialization
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Failed to register Rust plugin factory"}}];
        }}
        return nil;
    }}

    self = [super initWithComponentDescription:componentDescription
                                       options:options
                                         error:outError];

    if (self == nil) {{
        return nil;
    }}

    if (outError != NULL) {{
        *outError = nil;
    }}

    _instanceId = instanceId;
    _rustInstance = NULL;
    _instanceLock = [[NSLock alloc] init];
    _instanceValid = NO;
    _inputBusArray = nil;
    _outputBusArray = nil;
    _parameterTree = nil;
    _factoryPresets = nil;
    _sampleFormat = BeamerAuSampleFormatFloat32;
    _sampleRate = kDefaultSampleRate;
    _maxFrames = kDefaultMaxFrames;
    _resourcesAllocated = NO;
    memset(&_busConfig, 0, sizeof(_busConfig));

    AUAudioUnitPreset* defaultPreset = [[AUAudioUnitPreset alloc] init];
    defaultPreset.number = 0;
    defaultPreset.name = @"Default";
    _currentPreset = defaultPreset;

    _rustInstance = beamer_au_create_instance();
    if (_rustInstance == NULL) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FailedInitialization
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Failed to create Rust plugin instance"}}];
        }}
        return nil;
    }}

    _instanceValid = YES;

    if (![self setupBusArraysWithError:outError]) {{
        _instanceValid = NO;
        beamer_au_destroy_instance(_rustInstance);
        _rustInstance = NULL;
        return nil;
    }}

    // CRITICAL: Create render block eagerly during init.
    // The base class AUAudioUnit may set up MIDI forwarding (wiring
    // scheduleMIDIEventBlock -> realtimeEventListHead) during initialization.
    // If internalRenderBlock doesn't exist at that point, forwarding fails.
    (void)[self internalRenderBlock];

    return self;
}}

- (void)dealloc {{
    [_instanceLock lock];
    _instanceValid = NO;

    if (_rustInstance != NULL) {{
        if (_resourcesAllocated) {{
            beamer_au_deallocate_render_resources(_rustInstance);
            _resourcesAllocated = NO;
        }}
        beamer_au_destroy_instance(_rustInstance);
        _rustInstance = NULL;
    }}

    [_instanceLock unlock];
}}

// -----------------------------------------------------------------------------
// MARK: Bus Configuration
// -----------------------------------------------------------------------------

- (AUAudioUnitBus*)createBusAtIndex:(uint32_t)index
                            isInput:(BOOL)isInput
                      defaultFormat:(AVAudioFormat*)defaultFormat
                              error:(NSError**)outError {{
    uint32_t channelCount = isInput
        ? beamer_au_get_input_bus_channel_count(_rustInstance, index)
        : beamer_au_get_output_bus_channel_count(_rustInstance, index);

    if (channelCount == 0) channelCount = 2;
    if (channelCount > BEAMER_AU_MAX_CHANNELS) channelCount = BEAMER_AU_MAX_CHANNELS;

    AVAudioFormat* format = [[AVAudioFormat alloc]
        initStandardFormatWithSampleRate:kDefaultSampleRate
                                channels:(AVAudioChannelCount)channelCount];
    if (format == nil) {{
        format = defaultFormat;
    }}

    NSError* busError = nil;
    AUAudioUnitBus* bus = [[AUAudioUnitBus alloc] initWithFormat:format error:&busError];
    if (bus == nil) {{
        if (outError != NULL) {{
            *outError = busError;
        }}
        return nil;
    }}

    bus.maximumChannelCount = BEAMER_AU_MAX_CHANNELS;

    if (isInput) {{
        bus.name = (index == 0) ? @"Main Input" : [NSString stringWithFormat:@"Aux Input %u", index];
    }} else {{
        bus.name = (index == 0) ? @"Main Output" : [NSString stringWithFormat:@"Aux Output %u", index];
    }}

    return bus;
}}

- (BOOL)setupBusArraysWithError:(NSError**)outError {{
    if (_rustInstance == NULL) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_Uninitialized
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Rust instance not initialized"}}];
        }}
        return NO;
    }}

    uint32_t inputBusCount = beamer_au_get_input_bus_count(_rustInstance);
    uint32_t outputBusCount = beamer_au_get_output_bus_count(_rustInstance);

    if (inputBusCount > BEAMER_AU_MAX_BUSES) inputBusCount = BEAMER_AU_MAX_BUSES;
    if (outputBusCount > BEAMER_AU_MAX_BUSES) outputBusCount = BEAMER_AU_MAX_BUSES;

    if (inputBusCount == 0 && outputBusCount == 0) {{
        outputBusCount = 1;
    }}

    AVAudioFormat* stereoFormat = [[AVAudioFormat alloc]
        initStandardFormatWithSampleRate:kDefaultSampleRate
                                channels:2];

    NSMutableArray<AUAudioUnitBus*>* inputBuses = [[NSMutableArray alloc] initWithCapacity:inputBusCount];
    for (uint32_t i = 0; i < inputBusCount; i++) {{
        AUAudioUnitBus* bus = [self createBusAtIndex:i
                                             isInput:YES
                                       defaultFormat:stereoFormat
                                               error:outError];
        if (bus == nil) {{
            return NO;
        }}
        [inputBuses addObject:bus];
    }}

    NSMutableArray<AUAudioUnitBus*>* outputBuses = [[NSMutableArray alloc] initWithCapacity:outputBusCount];
    for (uint32_t i = 0; i < outputBusCount; i++) {{
        AUAudioUnitBus* bus = [self createBusAtIndex:i
                                             isInput:NO
                                       defaultFormat:stereoFormat
                                               error:outError];
        if (bus == nil) {{
            return NO;
        }}
        [outputBuses addObject:bus];
    }}

    _inputBusArray = [[AUAudioUnitBusArray alloc] initWithAudioUnit:self
                                                           busType:AUAudioUnitBusTypeInput
                                                            busses:inputBuses];
    _outputBusArray = [[AUAudioUnitBusArray alloc] initWithAudioUnit:self
                                                            busType:AUAudioUnitBusTypeOutput
                                                             busses:outputBuses];

    return YES;
}}

- (void)buildBusConfig {{
    memset(&_busConfig, 0, sizeof(_busConfig));

    _busConfig.input_bus_count = (uint32_t)_inputBusArray.count;
    for (uint32_t i = 0; i < _busConfig.input_bus_count && i < BEAMER_AU_MAX_BUSES; i++) {{
        _busConfig.input_buses[i].channel_count = (uint32_t)_inputBusArray[i].format.channelCount;
        _busConfig.input_buses[i].bus_type = (i == 0) ? BeamerAuBusTypeMain : BeamerAuBusTypeAuxiliary;
    }}

    _busConfig.output_bus_count = (uint32_t)_outputBusArray.count;
    for (uint32_t i = 0; i < _busConfig.output_bus_count && i < BEAMER_AU_MAX_BUSES; i++) {{
        _busConfig.output_buses[i].channel_count = (uint32_t)_outputBusArray[i].format.channelCount;
        _busConfig.output_buses[i].bus_type = (i == 0) ? BeamerAuBusTypeMain : BeamerAuBusTypeAuxiliary;
    }}
}}

// -----------------------------------------------------------------------------
// MARK: Bus Properties
// -----------------------------------------------------------------------------

- (AUAudioUnitBusArray*)inputBusses {{
    return _inputBusArray;
}}

- (AUAudioUnitBusArray*)outputBusses {{
    return _outputBusArray;
}}

// -----------------------------------------------------------------------------
// MARK: Format Validation
// -----------------------------------------------------------------------------

- (BOOL)shouldChangeToFormat:(AVAudioFormat*)format forBus:(AUAudioUnitBus*)bus {{
    // Get the channel capabilities to validate against
    BeamerAuChannelCapabilities caps;
    if (!beamer_au_get_channel_capabilities(_rustInstance, &caps)) {{
        // Can't get capabilities, let the superclass decide
        return [super shouldChangeToFormat:format forBus:bus];
    }}

    // If no specific capabilities, accept any format
    if (caps.count == 0) {{
        return [super shouldChangeToFormat:format forBus:bus];
    }}

    // Determine which bus this is (input or output, and which index)
    BOOL isInput = NO;
    NSUInteger busIndex = NSNotFound;

    for (NSUInteger i = 0; i < _inputBusArray.count; i++) {{
        if (_inputBusArray[i] == bus) {{
            isInput = YES;
            busIndex = i;
            break;
        }}
    }}

    if (busIndex == NSNotFound) {{
        for (NSUInteger i = 0; i < _outputBusArray.count; i++) {{
            if (_outputBusArray[i] == bus) {{
                isInput = NO;
                busIndex = i;
                break;
            }}
        }}
    }}

    // Only validate main bus (index 0) format changes
    if (busIndex != 0) {{
        return [super shouldChangeToFormat:format forBus:bus];
    }}

    uint32_t newChannelCount = (uint32_t)format.channelCount;

    // Get the current channel count for the other bus direction
    uint32_t inputChannels = isInput ? newChannelCount : (uint32_t)(_inputBusArray.count > 0 ? _inputBusArray[0].format.channelCount : 0);
    uint32_t outputChannels = isInput ? (uint32_t)(_outputBusArray.count > 0 ? _outputBusArray[0].format.channelCount : 0) : newChannelCount;

    // Check if this configuration matches any declared capability
    for (uint32_t i = 0; i < caps.count; i++) {{
        int32_t capInput = caps.capabilities[i].input_channels;
        int32_t capOutput = caps.capabilities[i].output_channels;

        BOOL inputMatches = (capInput == -1) || (capInput == (int32_t)inputChannels);
        BOOL outputMatches = (capOutput == -1) || (capOutput == (int32_t)outputChannels);

        // For wildcard capabilities ([-1, -1]), also require channels to match
        if (capInput == -1 && capOutput == -1) {{
            if (inputChannels == outputChannels) {{
                return [super shouldChangeToFormat:format forBus:bus];
            }}
        }} else if (inputMatches && outputMatches) {{
            return [super shouldChangeToFormat:format forBus:bus];
        }}
    }}

    // No matching capability found, reject the format change
    return NO;
}}

// -----------------------------------------------------------------------------
// MARK: Render Resources
// -----------------------------------------------------------------------------

- (BOOL)allocateRenderResourcesAndReturnError:(NSError**)outError {{
    if (_rustInstance == NULL) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_Uninitialized
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Rust instance not initialized"}}];
        }}
        return NO;
    }}

    if (![super allocateRenderResourcesAndReturnError:outError]) {{
        return NO;
    }}

    [self buildBusConfig];

    uint32_t mainInputChannels = (_busConfig.input_bus_count > 0) ? _busConfig.input_buses[0].channel_count : 0;
    uint32_t mainOutputChannels = (_busConfig.output_bus_count > 0) ? _busConfig.output_buses[0].channel_count : 0;

    if (!beamer_au_is_channel_config_valid(_rustInstance, mainInputChannels, mainOutputChannels)) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FormatNotSupported
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Channel configuration not supported"}}];
        }}
        self.renderResourcesAllocated = NO;
        [super deallocateRenderResources];
        return NO;
    }}

    AVAudioFormat* format = nil;
    if (_outputBusArray.count > 0) {{
        format = _outputBusArray[0].format;
    }} else if (_inputBusArray.count > 0) {{
        format = _inputBusArray[0].format;
    }}

    if (format != nil) {{
        _sampleRate = format.sampleRate;
        _sampleFormat = (format.commonFormat == AVAudioPCMFormatFloat64)
            ? BeamerAuSampleFormatFloat64
            : BeamerAuSampleFormatFloat32;
    }} else {{
        _sampleRate = kDefaultSampleRate;
        _sampleFormat = BeamerAuSampleFormatFloat32;
    }}

    _maxFrames = self.maximumFramesToRender;
    if (_maxFrames == 0) {{
        _maxFrames = kDefaultMaxFrames;
    }}

    if (_inputBusArray.count > 0) {{
        AVAudioFormat* inputFormat = _inputBusArray[0].format;
        _inputPCMBuffer = [[AVAudioPCMBuffer alloc] initWithPCMFormat:inputFormat
                                                       frameCapacity:_maxFrames];
        if (_inputPCMBuffer != nil) {{
            _inputMutableABL = _inputPCMBuffer.mutableAudioBufferList;
        }}
    }}

    OSStatus result = beamer_au_allocate_render_resources(
        _rustInstance,
        _sampleRate,
        _maxFrames,
        _sampleFormat,
        &_busConfig
    );

    if (result != noErr) {{
        if (outError != NULL) {{
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:result
                                        userInfo:@{{NSLocalizedDescriptionKey: @"Failed to allocate Rust render resources"}}];
        }}
        [super deallocateRenderResources];
        return NO;
    }}

    _resourcesAllocated = YES;
    return YES;
}}

- (void)deallocateRenderResources {{
    _inputMutableABL = NULL;
    _inputPCMBuffer = nil;

    if (_rustInstance != NULL && _resourcesAllocated) {{
        beamer_au_deallocate_render_resources(_rustInstance);
        _resourcesAllocated = NO;
    }}

    [super deallocateRenderResources];
}}

// -----------------------------------------------------------------------------
// MARK: Render Block
// -----------------------------------------------------------------------------

- (AUInternalRenderBlock)internalRenderBlock {{
    // Cache the render block instance. This block is created eagerly during init()
    // to ensure the base class AUAudioUnit can set up MIDI forwarding (wiring
    // scheduleMIDIEventBlock -> realtimeEventListHead) at the right time.
    if (_cachedInternalRenderBlock != nil) {{
        return _cachedInternalRenderBlock;
    }}

    BeamerAuInstanceHandle rustInstance = _rustInstance;

    // Capture self to access instance variables and host blocks dynamically.
    // This is necessary because the host may call internalRenderBlock before
    // allocateRenderResourcesAndReturnError, so capturing by value would get nil.
    // Host blocks (musicalContextBlock, transportStateBlock) are accessed dynamically
    // as they may be set after block creation.
    // Use __unsafe_unretained to avoid retain cycle (AU lifecycle guarantees validity).
    __unsafe_unretained typeof(self) blockSelf = self;

    _cachedInternalRenderBlock = ^AUAudioUnitStatus(
        AudioUnitRenderActionFlags* actionFlags,
        const AudioTimeStamp* timestamp,
        AUAudioFrameCount frameCount,
        NSInteger outputBusNumber,
        AudioBufferList* outputData,
        const AURenderEvent* realtimeEventListHead,
        AURenderPullInputBlock __unsafe_unretained pullInputBlock
    ) {{
        if (rustInstance == NULL) {{
            return kAudioUnitErr_Uninitialized;
        }}

        // Access these dynamically - they're set in allocateRenderResourcesAndReturnError
        AVAudioPCMBuffer* inputPCMBuffer = blockSelf->_inputPCMBuffer;
        AudioBufferList* inputMutableABL = blockSelf->_inputMutableABL;
        AUAudioFrameCount maxFrames = blockSelf->_maxFrames;

        AudioBufferList* inputData = NULL;
        if (inputPCMBuffer != nil && inputMutableABL != NULL && pullInputBlock != nil
            && frameCount <= maxFrames) {{
            const AudioBufferList* originalABL = inputPCMBuffer.audioBufferList;
            UInt32 byteSize = frameCount * sizeof(float);

            inputMutableABL->mNumberBuffers = originalABL->mNumberBuffers;
            for (UInt32 i = 0; i < originalABL->mNumberBuffers; ++i) {{
                inputMutableABL->mBuffers[i].mNumberChannels = originalABL->mBuffers[i].mNumberChannels;
                inputMutableABL->mBuffers[i].mData = originalABL->mBuffers[i].mData;
                inputMutableABL->mBuffers[i].mDataByteSize = byteSize;
            }}

            AudioUnitRenderActionFlags pullFlags = 0;
            AUAudioUnitStatus pullStatus = pullInputBlock(&pullFlags, timestamp, frameCount, 0, inputMutableABL);
            if (pullStatus == noErr) {{
                inputData = inputMutableABL;
            }}
        }}

        // Access host blocks dynamically - they may be set after block creation
        AUHostMusicalContextBlock musicalContext = blockSelf.musicalContextBlock;
        AUHostTransportStateBlock transportState = blockSelf.transportStateBlock;

        // Use realtimeEventListHead directly from the base class.
        // The base class AUAudioUnit should forward MIDI events from
        // scheduleMIDIEventBlock to this parameter automatically.
        return beamer_au_render(
            rustInstance,
            actionFlags,
            timestamp,
            frameCount,
            outputBusNumber,
            outputData,
            realtimeEventListHead,
            pullInputBlock,
            inputData,
            musicalContext,
            transportState,
            NULL
        );
    }};

    return _cachedInternalRenderBlock;
}}

// -----------------------------------------------------------------------------
// MARK: Parameters
// -----------------------------------------------------------------------------

- (AUParameterTree*)parameterTree {{
    if (_parameterTree == nil) {{
        [self buildParameterTree];
    }}
    return _parameterTree;
}}

- (void)buildParameterTree {{
    if (_rustInstance == NULL) {{
        _parameterTree = nil;
        return;
    }}

    uint32_t paramCount = beamer_au_get_parameter_count(_rustInstance);
    uint32_t groupCount = beamer_au_get_group_count(_rustInstance);

    if (paramCount == 0) {{
        _parameterTree = [AUParameterTree createTreeWithChildren:@[]];
        return;
    }}

    // Collect parameters
    NSMutableArray<NSDictionary*>* allParams = [[NSMutableArray alloc] initWithCapacity:paramCount];
    for (uint32_t i = 0; i < paramCount; i++) {{
        BeamerAuParameterInfo info;
        if (!beamer_au_get_parameter_info(_rustInstance, i, &info)) {{
            continue;
        }}

        NSString* identifier = [NSString stringWithFormat:@"param_%u", info.id];
        NSString* name = [NSString stringWithUTF8String:info.name];
        // Use the unit_type directly from Rust instead of inferring from string
        AudioUnitParameterUnit auUnit = (AudioUnitParameterUnit)info.unit_type;

        AudioUnitParameterOptions flags = kAudioUnitParameterFlag_IsReadable;
        if (!(info.flags & BeamerAuParameterFlagReadOnly)) {{
            flags |= kAudioUnitParameterFlag_IsWritable;
        }}

        // Build valueStrings array for indexed parameters (enums)
        NSArray<NSString*>* valueStrings = nil;
        uint32_t valueCount = beamer_au_get_parameter_value_count(_rustInstance, info.id);
        if (valueCount > 0) {{
            NSMutableArray<NSString*>* strings = [[NSMutableArray alloc] initWithCapacity:valueCount];
            char stringBuffer[128];
            for (uint32_t vi = 0; vi < valueCount; vi++) {{
                if (beamer_au_get_parameter_value_string(_rustInstance, info.id, vi, stringBuffer, sizeof(stringBuffer))) {{
                    [strings addObject:[NSString stringWithUTF8String:stringBuffer]];
                }}
            }}
            if (strings.count == valueCount) {{
                valueStrings = strings;
            }}
        }}

        // Set parameter range and default based on type
        float paramMin;
        float paramMax;
        float paramDefault;

        if (info.unit_type == kAudioUnitParameterUnit_Indexed) {{
            // For indexed parameters, use integer range (0 to step_count)
            paramMin = 0.0f;
            paramMax = (float)info.step_count;
            paramDefault = roundf(info.default_value * info.step_count);
        }} else {{
            // For continuous parameters, use actual value range (e.g., -60 to +12 dB)
            paramMin = info.min_value;
            paramMax = info.max_value;
            paramDefault = info.default_value;
        }}

        AUParameter* param = [AUParameterTree createParameterWithIdentifier:identifier
                                                                       name:name
                                                                    address:(AUParameterAddress)info.id
                                                                        min:paramMin
                                                                        max:paramMax
                                                                       unit:auUnit
                                                                   unitName:nil
                                                                      flags:flags
                                                               valueStrings:valueStrings
                                                        dependentParameters:nil];
        param.value = paramDefault;

        [allParams addObject:@{{
            @"param": param,
            @"groupId": @(info.group_id)
        }}];
    }}

    // Collect groups (skip index 0 = root)
    NSMutableDictionary<NSNumber*, NSDictionary*>* groupInfoMap = [[NSMutableDictionary alloc] init];
    for (uint32_t i = 1; i < groupCount; i++) {{
        BeamerAuGroupInfo ginfo;
        if (beamer_au_get_group_info(_rustInstance, i, &ginfo)) {{
            NSString* gname = [NSString stringWithUTF8String:ginfo.name];
            groupInfoMap[@(ginfo.id)] = @{{
                @"name": gname,
                @"parentId": @(ginfo.parent_id)
            }};
        }}
    }}

    // Build group hierarchy
    NSMutableDictionary<NSNumber*, AUParameterGroup*>* groupNodes = [[NSMutableDictionary alloc] init];
    NSMutableDictionary<NSNumber*, NSMutableArray<AUParameterNode*>*>* groupChildren = [[NSMutableDictionary alloc] init];

    groupChildren[@0] = [[NSMutableArray alloc] init];
    for (NSNumber* gid in groupInfoMap) {{
        groupChildren[gid] = [[NSMutableArray alloc] init];
    }}

    // Assign parameters to groups
    for (NSDictionary* pdict in allParams) {{
        NSNumber* gid = pdict[@"groupId"];
        NSMutableArray* children = groupChildren[gid];
        if (children == nil) {{
            children = groupChildren[@0];
        }}
        [children addObject:pdict[@"param"]];
    }}

    // Build groups bottom-up
    NSMutableSet<NSNumber*>* remaining = [NSMutableSet setWithArray:groupInfoMap.allKeys];
    while (remaining.count > 0) {{
        BOOL madeProgress = NO;
        for (NSNumber* gid in [remaining copy]) {{
            NSDictionary* ginfo = groupInfoMap[gid];
            NSNumber* parentId = ginfo[@"parentId"];

            if ([parentId intValue] == 0 || groupNodes[parentId] != nil) {{
                NSString* gname = ginfo[@"name"];
                NSString* gidentifier = [NSString stringWithFormat:@"group_%d", [gid intValue]];

                AUParameterGroup* group = [AUParameterTree createGroupWithIdentifier:gidentifier
                                                                                name:gname
                                                                            children:groupChildren[gid]];
                groupNodes[gid] = group;
                [groupChildren[parentId] addObject:group];

                [remaining removeObject:gid];
                madeProgress = YES;
            }}
        }}

        if (!madeProgress && remaining.count > 0) {{
            for (NSNumber* gid in remaining) {{
                NSDictionary* ginfo = groupInfoMap[gid];
                NSString* gname = ginfo[@"name"];
                NSString* gidentifier = [NSString stringWithFormat:@"group_%d", [gid intValue]];

                AUParameterGroup* group = [AUParameterTree createGroupWithIdentifier:gidentifier
                                                                                name:gname
                                                                            children:groupChildren[gid]];
                groupNodes[gid] = group;
                [groupChildren[@0] addObject:group];
            }}
            break;
        }}
    }}

    _parameterTree = [AUParameterTree createTreeWithChildren:groupChildren[@0]];
    [self setupParameterCallbacks];
}}

- (void)setupParameterCallbacks {{
    if (_parameterTree == nil || _rustInstance == NULL) {{
        return;
    }}

    __weak typeof(self) weakSelf = self;

    _parameterTree.implementorValueProvider = ^AUValue(AUParameter* param) {{
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil) {{
            return 0.0f;
        }}

        [strongSelf->_instanceLock lock];
        AUValue result = 0.0f;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {{
            // Get actual value from Rust (handles conversion from normalized internally)
            result = beamer_au_get_parameter_value_au(strongSelf->_rustInstance, (uint32_t)param.address);
        }}
        [strongSelf->_instanceLock unlock];
        return result;
    }};

    _parameterTree.implementorValueObserver = ^(AUParameter* param, AUValue value) {{
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil) {{
            return;
        }}

        [strongSelf->_instanceLock lock];
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {{
            // Set actual value to Rust (handles conversion to normalized internally)
            beamer_au_set_parameter_value_au(strongSelf->_rustInstance, (uint32_t)param.address, value);
        }}
        [strongSelf->_instanceLock unlock];
    }};

    _parameterTree.implementorStringFromValueCallback = ^NSString* _Nonnull(AUParameter* param, const AUValue* value) {{
        __strong typeof(self) strongSelf = weakSelf;
        AUValue displayValue = (value != NULL) ? *value : param.value;

        if (strongSelf == nil) {{
            return [NSString stringWithFormat:@"%.2f", displayValue];
        }}

        [strongSelf->_instanceLock lock];
        NSString* result = nil;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {{
            // Convert actual value to normalized for formatting (Rust expects normalized)
            float normalizedValue = 0.0f;
            if (param.unit == kAudioUnitParameterUnit_Indexed && param.maxValue > 0) {{
                // Indexed: index / step_count = normalized
                normalizedValue = displayValue / param.maxValue;
            }} else if (param.maxValue > param.minValue) {{
                // Continuous: (actual - min) / (max - min) = normalized
                normalizedValue = (displayValue - param.minValue) / (param.maxValue - param.minValue);
            }}
            char buffer[128];
            uint32_t written = beamer_au_format_parameter_value(
                strongSelf->_rustInstance,
                (uint32_t)param.address,
                normalizedValue,
                buffer,
                sizeof(buffer)
            );
            if (written > 0) {{
                result = [NSString stringWithUTF8String:buffer];
            }}
        }}
        [strongSelf->_instanceLock unlock];

        return (result != nil) ? result : [NSString stringWithFormat:@"%.2f", displayValue];
    }};

    _parameterTree.implementorValueFromStringCallback = ^AUValue(AUParameter* param, NSString* string) {{
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil || string == nil) {{
            return param.value;
        }}

        [strongSelf->_instanceLock lock];
        AUValue result = param.value;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {{
            float parsedNormalized = 0.0f;
            if (beamer_au_parse_parameter_value(strongSelf->_rustInstance, (uint32_t)param.address, string.UTF8String, &parsedNormalized)) {{
                // Convert normalized to actual value
                if (param.unit == kAudioUnitParameterUnit_Indexed && param.maxValue > 0) {{
                    // Indexed: normalized * step_count = index
                    result = roundf(parsedNormalized * param.maxValue);
                }} else {{
                    // Continuous: min + normalized * (max - min) = actual
                    result = param.minValue + parsedNormalized * (param.maxValue - param.minValue);
                }}
            }}
        }}
        [strongSelf->_instanceLock unlock];
        return result;
    }};
}}

// -----------------------------------------------------------------------------
// MARK: State Persistence
// -----------------------------------------------------------------------------

- (NSDictionary<NSString*, id>*)fullState {{
    NSMutableDictionary* state = [[super fullState] mutableCopy];
    if (state == nil) {{
        state = [[NSMutableDictionary alloc] init];
    }}

    if (_rustInstance != NULL) {{
        uint32_t stateSize = beamer_au_get_state_size(_rustInstance);
        if (stateSize > 0) {{
            uint8_t* buffer = (uint8_t*)malloc(stateSize);
            if (buffer != NULL) {{
                uint32_t written = beamer_au_get_state(_rustInstance, buffer, stateSize);
                if (written > 0) {{
                    NSData* stateData = [NSData dataWithBytes:buffer length:written];
                    state[@"beamerState"] = stateData;
                }}
                free(buffer);
            }}
        }}
    }}

    return state;
}}

- (void)setFullState:(NSDictionary<NSString*, id>*)fullState {{
    [super setFullState:fullState];

    if (_rustInstance != NULL && fullState != nil) {{
        NSData* stateData = fullState[@"beamerState"];
        if (stateData != nil && stateData.length > 0) {{
            OSStatus status = beamer_au_set_state(_rustInstance, stateData.bytes, (uint32_t)stateData.length);

            if (status != noErr) {{
                return;
            }}

            // Refresh AUParameter values from Rust to notify host UI.
            // Use beamer_au_get_parameter_value_au since AUParameters use actual value ranges.
            if (_parameterTree != nil) {{
                for (AUParameter* param in _parameterTree.allParameters) {{
                    AUValue newValue = beamer_au_get_parameter_value_au(_rustInstance, (uint32_t)param.address);
                    [param setValue:newValue originator:nil];
                }}
            }}
        }}
    }}
}}

// -----------------------------------------------------------------------------
// MARK: Preset Properties
// -----------------------------------------------------------------------------

- (AUAudioUnitPreset*)currentPreset {{
    return _currentPreset;
}}

- (void)setCurrentPreset:(AUAudioUnitPreset*)currentPreset {{
    if (currentPreset == nil) {{
        _currentPreset = nil;
        return;
    }}
    _currentPreset = currentPreset;

    // Apply factory preset if it's a factory preset (number >= 0)
    if (currentPreset.number >= 0) {{
        [self applyFactoryPreset:(int)currentPreset.number];
    }}
}}

- (void)applyFactoryPreset:(int)presetNumber {{
    if (_rustInstance == NULL) {{
        return;
    }}

    // Apply preset via Rust bridge (sets all parameter values)
    if (!beamer_au_apply_preset(_rustInstance, (uint32_t)presetNumber)) {{
        return;
    }}

    // CRITICAL: Refresh all AUParameter values from Rust to notify host UI.
    // After applying a preset, the parameter values in Rust have changed.
    // We must update the AUParameter objects so the host UI reflects the changes.
    // Use beamer_au_get_parameter_value_au to get actual values (not normalized)
    // since AUParameters now use actual value ranges.
    if (_parameterTree != nil) {{
        for (AUParameter* param in _parameterTree.allParameters) {{
            AUValue newValue = beamer_au_get_parameter_value_au(_rustInstance, (uint32_t)param.address);
            [param setValue:newValue originator:nil];
        }}
    }}
}}

- (NSArray<AUAudioUnitPreset*>*)factoryPresets {{
    if (_factoryPresets == nil && _rustInstance != NULL) {{
        uint32_t presetCount = beamer_au_get_preset_count(_rustInstance);

        if (presetCount > 0) {{
            NSMutableArray<AUAudioUnitPreset*>* presets = [[NSMutableArray alloc] initWithCapacity:presetCount];

            for (uint32_t i = 0; i < presetCount; i++) {{
                BeamerAuPresetInfo info;
                memset(&info, 0, sizeof(info));

                if (beamer_au_get_preset_info(_rustInstance, i, &info)) {{
                    AUAudioUnitPreset* preset = [[AUAudioUnitPreset alloc] init];
                    preset.number = (NSInteger)info.number;
                    preset.name = [NSString stringWithUTF8String:info.name];
                    [presets addObject:preset];
                }}
            }}

            _factoryPresets = [presets copy];
        }}
    }}
    return _factoryPresets;
}}

// -----------------------------------------------------------------------------
// MARK: Processing Properties
// -----------------------------------------------------------------------------

- (NSTimeInterval)latency {{
    if (_rustInstance == NULL || _sampleRate <= 0.0) {{
        return 0.0;
    }}
    uint32_t latencySamples = beamer_au_get_latency_samples(_rustInstance);
    return (NSTimeInterval)latencySamples / _sampleRate;
}}

- (NSTimeInterval)tailTime {{
    if (_rustInstance == NULL || _sampleRate <= 0.0) {{
        return 0.0;
    }}
    uint32_t tailSamples = beamer_au_get_tail_samples(_rustInstance);
    if (tailSamples == UINT32_MAX) {{
        return INFINITY;
    }}
    return (NSTimeInterval)tailSamples / _sampleRate;
}}

- (BOOL)supportsMPE {{
    return NO;
}}

- (NSArray<NSString*>*)MIDIOutputNames {{
    // Return empty array - we don't have MIDI output
    return @[];
}}

- (BOOL)supportsUserPresets {{
    return YES;
}}

- (NSArray<NSNumber*>*)channelCapabilities {{
    // Query the declared channel capabilities from the Rust plugin
    BeamerAuChannelCapabilities caps;
    if (!beamer_au_get_channel_capabilities(_rustInstance, &caps)) {{
        // Failed to get capabilities, fall back to "any supported"
        return nil;
    }}

    if (caps.count == 0) {{
        // No specific capabilities declared, "any supported"
        return nil;
    }}

    // Convert capabilities to NSArray<NSNumber*> format
    // AU expects pairs of [input, output] channel counts
    NSMutableArray<NSNumber*>* result = [[NSMutableArray alloc] initWithCapacity:caps.count * 2];
    for (uint32_t i = 0; i < caps.count; i++) {{
        [result addObject:@(caps.capabilities[i].input_channels)];
        [result addObject:@(caps.capabilities[i].output_channels)];
    }}
    return result;
}}

- (void)reset {{
    if (_rustInstance != NULL) {{
        beamer_au_reset(_rustInstance);
    }}
}}

- (BOOL)canProcessInPlace {{
    return NO;
}}

@end
"#, plugin_name = plugin_name, wrapper_class = wrapper_class)
}

/// Generate AUv2 wrapper source code.
///
/// This generates a complete AUv2 plugin implementation with:
/// - AudioComponentPlugInInterface struct with Open/Close/Lookup
/// - Selector handlers for Initialize, Render, GetProperty, etc.
/// - All handlers call the beamer_au_* bridge functions
fn generate_auv2_wrapper_source(plugin_name: &str) -> String {
    let pascal_name = to_pascal_case(plugin_name);
    let factory_name = format!("Beamer{}Factory", pascal_name);

    format!(
        r#"
// =============================================================================
// AUv2 Plugin Implementation for {plugin_name}
// =============================================================================
// Auto-generated proper AUv2 implementation that returns AudioComponentPlugInInterface*.
// All plugin logic is handled by the beamer_au_* bridge functions.

#include <AudioToolbox/AudioToolbox.h>
#include <AudioUnit/AudioUnit.h>
#include <CoreFoundation/CoreFoundation.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

// Include the bridge header for Rust plugin access
#include "BeamerAuBridge.h"

// =============================================================================
// MARK: - Constants
// =============================================================================

#define MAX_PROPERTY_LISTENERS 64
#define MAX_RENDER_NOTIFY 32

// =============================================================================
// MARK: - Data Structures
// =============================================================================

typedef struct {{
    AudioUnitPropertyID propID;
    AudioUnitPropertyListenerProc proc;
    void* userData;
}} PropertyListener;

typedef struct {{
    AURenderCallback proc;
    void* userData;
}} RenderNotify;

typedef struct {{
    AudioUnit sourceAU;
    UInt32 sourceOutputNumber;
}} InputConnection;

typedef struct BeamerAuv2Instance {{
    // AudioComponentPlugInInterface MUST be first (ABI requirement)
    AudioComponentPlugInInterface interface;
    AudioComponentInstance componentInstance;
    BeamerAuInstanceHandle rustInstance;

    // Audio configuration
    Float64 sampleRate;
    UInt32 maxFramesPerSlice;
    bool initialized;
    bool bypassed;

    // Stream formats for input/output scope, element 0
    AudioStreamBasicDescription inputFormat;
    AudioStreamBasicDescription outputFormat;

    // Input handling - either callback or connection
    AURenderCallbackStruct inputCallback;
    InputConnection inputConnection;

    // Allocated input buffer for pulling
    AudioBufferList* inputBufferList;
    UInt32 inputBufferCapacity;

    // Property listeners
    PropertyListener propertyListeners[MAX_PROPERTY_LISTENERS];
    UInt32 propertyListenerCount;
    pthread_mutex_t listenerMutex;

    // Render notifications
    RenderNotify renderNotify[MAX_RENDER_NOTIFY];
    UInt32 renderNotifyCount;
    pthread_mutex_t renderNotifyMutex;

    // Host callbacks (for tempo, transport, etc.)
    HostCallbackInfo hostCallbacks;

    // Factory presets
    CFArrayRef factoryPresets;         // CFArray of AUPreset pointers (NULL callbacks)
    AUPreset* presetStorage;           // Backing storage for preset structs
    uint32_t presetCount;              // Number of factory presets
    int32_t currentPresetIndex;        // -1 = no preset, >=0 = factory preset index
}} BeamerAuv2Instance;

// =============================================================================
// MARK: - Forward Declarations
// =============================================================================

static OSStatus BeamerAuv2Open(void* self, AudioComponentInstance ci);
static OSStatus BeamerAuv2Close(void* self);
static AudioComponentMethod BeamerAuv2Lookup(SInt16 selector);

static OSStatus BeamerAuv2Initialize(void* self);
static OSStatus BeamerAuv2Uninitialize(void* self);
static OSStatus BeamerAuv2GetPropertyInfo(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, UInt32* outDataSize, Boolean* outWritable);
static OSStatus BeamerAuv2GetProperty(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, void* outData, UInt32* ioDataSize);
static OSStatus BeamerAuv2SetProperty(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, const void* inData, UInt32 inDataSize);
static OSStatus BeamerAuv2AddPropertyListener(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc, void* userData);
static OSStatus BeamerAuv2RemovePropertyListener(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc);
static OSStatus BeamerAuv2RemovePropertyListenerWithUserData(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc, void* userData);
static OSStatus BeamerAuv2GetParameter(void* self, AudioUnitParameterID paramID,
    AudioUnitScope scope, AudioUnitElement element, AudioUnitParameterValue* outValue);
static OSStatus BeamerAuv2SetParameter(void* self, AudioUnitParameterID paramID,
    AudioUnitScope scope, AudioUnitElement element, AudioUnitParameterValue value, UInt32 bufferOffset);
static OSStatus BeamerAuv2ScheduleParameters(void* self, const AudioUnitParameterEvent* events, UInt32 numEvents);
static OSStatus BeamerAuv2Render(void* self, AudioUnitRenderActionFlags* ioActionFlags,
    const AudioTimeStamp* inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList* ioData);
static OSStatus BeamerAuv2Reset(void* self, AudioUnitScope scope, AudioUnitElement element);
static OSStatus BeamerAuv2AddRenderNotify(void* self, AURenderCallback proc, void* userData);
static OSStatus BeamerAuv2RemoveRenderNotify(void* self, AURenderCallback proc, void* userData);

// =============================================================================
// MARK: - Helper Functions
// =============================================================================

static void InitDefaultFormat(AudioStreamBasicDescription* format, Float64 sampleRate, UInt32 channels) {{
    memset(format, 0, sizeof(AudioStreamBasicDescription));
    format->mSampleRate = sampleRate;
    format->mFormatID = kAudioFormatLinearPCM;
    format->mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;
    format->mBytesPerPacket = sizeof(Float32);
    format->mFramesPerPacket = 1;
    format->mBytesPerFrame = sizeof(Float32);
    format->mChannelsPerFrame = channels;
    format->mBitsPerChannel = 32;
}}

static void NotifyPropertyListeners(BeamerAuv2Instance* inst, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element) {{
    pthread_mutex_lock(&inst->listenerMutex);
    for (UInt32 i = 0; i < inst->propertyListenerCount; i++) {{
        if (inst->propertyListeners[i].propID == propID) {{
            inst->propertyListeners[i].proc(
                inst->propertyListeners[i].userData,
                inst->componentInstance,
                propID, scope, element);
        }}
    }}
    pthread_mutex_unlock(&inst->listenerMutex);
}}

static OSStatus EnsureInputBufferList(BeamerAuv2Instance* inst, UInt32 channels, UInt32 frames) {{
    UInt32 neededCapacity = frames * channels;
    if (inst->inputBufferList && inst->inputBufferCapacity >= neededCapacity) {{
        // Existing buffer is large enough, just update frame counts
        for (UInt32 i = 0; i < inst->inputBufferList->mNumberBuffers; i++) {{
            inst->inputBufferList->mBuffers[i].mDataByteSize = frames * sizeof(Float32);
        }}
        return noErr;
    }}

    // Free old buffer if it exists
    if (inst->inputBufferList) {{
        for (UInt32 i = 0; i < inst->inputBufferList->mNumberBuffers; i++) {{
            if (inst->inputBufferList->mBuffers[i].mData) {{
                free(inst->inputBufferList->mBuffers[i].mData);
            }}
        }}
        free(inst->inputBufferList);
    }}

    // Allocate new buffer list (non-interleaved: one buffer per channel)
    size_t listSize = sizeof(AudioBufferList) + (channels > 0 ? (channels - 1) * sizeof(AudioBuffer) : 0);
    inst->inputBufferList = (AudioBufferList*)calloc(1, listSize);
    if (!inst->inputBufferList) return kAudio_MemFullError;

    inst->inputBufferList->mNumberBuffers = channels;
    for (UInt32 i = 0; i < channels; i++) {{
        inst->inputBufferList->mBuffers[i].mNumberChannels = 1;
        inst->inputBufferList->mBuffers[i].mDataByteSize = frames * sizeof(Float32);
        inst->inputBufferList->mBuffers[i].mData = calloc(frames, sizeof(Float32));
        if (!inst->inputBufferList->mBuffers[i].mData) return kAudio_MemFullError;
    }}

    inst->inputBufferCapacity = neededCapacity;
    return noErr;
}}

static void FreeInputBufferList(BeamerAuv2Instance* inst) {{
    if (inst->inputBufferList) {{
        for (UInt32 i = 0; i < inst->inputBufferList->mNumberBuffers; i++) {{
            if (inst->inputBufferList->mBuffers[i].mData) {{
                free(inst->inputBufferList->mBuffers[i].mData);
            }}
        }}
        free(inst->inputBufferList);
        inst->inputBufferList = NULL;
        inst->inputBufferCapacity = 0;
    }}
}}

// =============================================================================
// MARK: - Factory Function
// =============================================================================

__attribute__((visibility("default")))
void* {factory_name}(const AudioComponentDescription* inDesc) {{
    (void)inDesc;

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)calloc(1, sizeof(BeamerAuv2Instance));
    if (!inst) return NULL;

    // Set up the interface function pointers
    inst->interface.Open = BeamerAuv2Open;
    inst->interface.Close = BeamerAuv2Close;
    inst->interface.Lookup = BeamerAuv2Lookup;
    inst->interface.reserved = NULL;

    // Set defaults
    inst->sampleRate = 44100.0;
    inst->maxFramesPerSlice = 1024;
    inst->initialized = false;
    inst->bypassed = false;

    // Initialize mutexes
    pthread_mutex_init(&inst->listenerMutex, NULL);
    pthread_mutex_init(&inst->renderNotifyMutex, NULL);

    return &inst->interface;
}}

// =============================================================================
// MARK: - Open/Close/Lookup
// =============================================================================

static OSStatus BeamerAuv2Open(void* self, AudioComponentInstance ci) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;
    inst->componentInstance = ci;

    // Ensure Rust factory is registered
    if (!beamer_au_ensure_factory_registered()) {{
        return kAudioUnitErr_FailedInitialization;
    }}

    // Create Rust plugin instance
    inst->rustInstance = beamer_au_create_instance();
    if (!inst->rustInstance) {{
        return kAudioUnitErr_FailedInitialization;
    }}

    // Query bus configuration from Rust and set up default formats
    uint32_t inputChannels = beamer_au_get_input_bus_channel_count(inst->rustInstance, 0);
    uint32_t outputChannels = beamer_au_get_output_bus_channel_count(inst->rustInstance, 0);

    // Default to stereo if plugin reports 0 (shouldn't happen)
    if (inputChannels == 0 && beamer_au_get_input_bus_count(inst->rustInstance) > 0) inputChannels = 2;
    if (outputChannels == 0 && beamer_au_get_output_bus_count(inst->rustInstance) > 0) outputChannels = 2;

    InitDefaultFormat(&inst->inputFormat, inst->sampleRate, inputChannels);
    InitDefaultFormat(&inst->outputFormat, inst->sampleRate, outputChannels);

    // Build factory presets cache
    uint32_t presetCount = beamer_au_get_preset_count(inst->rustInstance);
    inst->presetCount = presetCount;
    inst->currentPresetIndex = -1;

    if (presetCount > 0) {{
        // Allocate backing storage for AUPreset structs
        inst->presetStorage = (AUPreset*)calloc(presetCount, sizeof(AUPreset));
        if (inst->presetStorage) {{
            // Initialize each preset from Rust
            for (uint32_t i = 0; i < presetCount; i++) {{
                BeamerAuPresetInfo info;
                memset(&info, 0, sizeof(info));
                if (beamer_au_get_preset_info(inst->rustInstance, i, &info)) {{
                    inst->presetStorage[i].presetNumber = (SInt32)info.number;
                    inst->presetStorage[i].presetName = CFStringCreateWithCString(
                        kCFAllocatorDefault, info.name, kCFStringEncodingUTF8);
                }}
            }}

            // Build CFArray with NULL callbacks (stores raw pointers to AUPreset)
            CFMutableArrayRef presets = CFArrayCreateMutable(kCFAllocatorDefault, presetCount, NULL);
            if (presets) {{
                for (uint32_t i = 0; i < presetCount; i++) {{
                    CFArrayAppendValue(presets, &inst->presetStorage[i]);
                }}
                inst->factoryPresets = presets;
            }} else {{
                inst->factoryPresets = NULL;
            }}
        }} else {{
            inst->factoryPresets = NULL;
            inst->presetCount = 0;
        }}
    }} else {{
        inst->factoryPresets = NULL;
        inst->presetStorage = NULL;
    }}

    return noErr;
}}

static OSStatus BeamerAuv2Close(void* self) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    if (inst->initialized) {{
        beamer_au_deallocate_render_resources(inst->rustInstance);
        inst->initialized = false;
    }}

    if (inst->rustInstance) {{
        beamer_au_destroy_instance(inst->rustInstance);
        inst->rustInstance = NULL;
    }}

    FreeInputBufferList(inst);

    // Release factory presets
    if (inst->factoryPresets) {{
        CFRelease(inst->factoryPresets);
        inst->factoryPresets = NULL;
    }}

    // Free preset storage and release dynamically created CFStrings
    if (inst->presetStorage) {{
        for (uint32_t i = 0; i < inst->presetCount; i++) {{
            if (inst->presetStorage[i].presetName) {{
                CFRelease(inst->presetStorage[i].presetName);
            }}
        }}
        free(inst->presetStorage);
        inst->presetStorage = NULL;
    }}

    pthread_mutex_destroy(&inst->listenerMutex);
    pthread_mutex_destroy(&inst->renderNotifyMutex);

    free(inst);
    return noErr;
}}

static AudioComponentMethod BeamerAuv2Lookup(SInt16 selector) {{
    switch (selector) {{
        case kAudioUnitInitializeSelect:
            return (AudioComponentMethod)BeamerAuv2Initialize;
        case kAudioUnitUninitializeSelect:
            return (AudioComponentMethod)BeamerAuv2Uninitialize;
        case kAudioUnitGetPropertyInfoSelect:
            return (AudioComponentMethod)BeamerAuv2GetPropertyInfo;
        case kAudioUnitGetPropertySelect:
            return (AudioComponentMethod)BeamerAuv2GetProperty;
        case kAudioUnitSetPropertySelect:
            return (AudioComponentMethod)BeamerAuv2SetProperty;
        case kAudioUnitAddPropertyListenerSelect:
            return (AudioComponentMethod)BeamerAuv2AddPropertyListener;
        case kAudioUnitRemovePropertyListenerSelect:
            return (AudioComponentMethod)BeamerAuv2RemovePropertyListener;
        case kAudioUnitRemovePropertyListenerWithUserDataSelect:
            return (AudioComponentMethod)BeamerAuv2RemovePropertyListenerWithUserData;
        case kAudioUnitGetParameterSelect:
            return (AudioComponentMethod)BeamerAuv2GetParameter;
        case kAudioUnitSetParameterSelect:
            return (AudioComponentMethod)BeamerAuv2SetParameter;
        case kAudioUnitScheduleParametersSelect:
            return (AudioComponentMethod)BeamerAuv2ScheduleParameters;
        case kAudioUnitRenderSelect:
            return (AudioComponentMethod)BeamerAuv2Render;
        case kAudioUnitResetSelect:
            return (AudioComponentMethod)BeamerAuv2Reset;
        case kAudioUnitAddRenderNotifySelect:
            return (AudioComponentMethod)BeamerAuv2AddRenderNotify;
        case kAudioUnitRemoveRenderNotifySelect:
            return (AudioComponentMethod)BeamerAuv2RemoveRenderNotify;
        default:
            return NULL;
    }}
}}

// =============================================================================
// MARK: - Initialize/Uninitialize
// =============================================================================

static OSStatus BeamerAuv2Initialize(void* self) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    if (inst->initialized) {{
        return noErr; // Already initialized
    }}

    // Build bus config from current stream formats
    BeamerAuBusConfig busConfig;
    memset(&busConfig, 0, sizeof(busConfig));

    uint32_t inputBusCount = beamer_au_get_input_bus_count(inst->rustInstance);
    uint32_t outputBusCount = beamer_au_get_output_bus_count(inst->rustInstance);

    busConfig.input_bus_count = inputBusCount;
    busConfig.output_bus_count = outputBusCount;

    uint32_t inputChannels = 0;
    uint32_t outputChannels = 0;

    if (inputBusCount > 0) {{
        inputChannels = inst->inputFormat.mChannelsPerFrame;
        busConfig.input_buses[0].channel_count = inputChannels;
        busConfig.input_buses[0].bus_type = BeamerAuBusTypeMain;
    }}
    if (outputBusCount > 0) {{
        outputChannels = inst->outputFormat.mChannelsPerFrame;
        busConfig.output_buses[0].channel_count = outputChannels;
        busConfig.output_buses[0].bus_type = BeamerAuBusTypeMain;
    }}

    // Validate channel configuration before proceeding
    bool configValid = beamer_au_is_channel_config_valid(inst->rustInstance, inputChannels, outputChannels);
    NSLog(@"AUv2 Initialize: input=%u output=%u valid=%d", inputChannels, outputChannels, configValid);
    if (!configValid) {{
        NSLog(@"AUv2 Initialize: Rejecting invalid channel config");
        return kAudioUnitErr_FormatNotSupported;
    }}

    // Determine sample format
    BeamerAuSampleFormat format = BeamerAuSampleFormatFloat32;
    if (inst->outputFormat.mBitsPerChannel == 64) {{
        format = BeamerAuSampleFormatFloat64;
    }}

    // Allocate render resources in Rust
    OSStatus status = beamer_au_allocate_render_resources(
        inst->rustInstance,
        inst->sampleRate,
        inst->maxFramesPerSlice,
        format,
        &busConfig
    );

    if (status == noErr) {{
        inst->initialized = true;

        // Pre-allocate input buffer if we have input buses
        if (inputBusCount > 0) {{
            EnsureInputBufferList(inst, inst->inputFormat.mChannelsPerFrame, inst->maxFramesPerSlice);
        }}
    }}

    return status;
}}

static OSStatus BeamerAuv2Uninitialize(void* self) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    if (inst->initialized) {{
        beamer_au_deallocate_render_resources(inst->rustInstance);
        inst->initialized = false;
    }}

    return noErr;
}}

// =============================================================================
// MARK: - Property Handling
// =============================================================================

static OSStatus BeamerAuv2GetPropertyInfo(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, UInt32* outDataSize, Boolean* outWritable) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    // Default to not writable
    if (outWritable) *outWritable = false;

    switch (propID) {{
        // Stream format
        case kAudioUnitProperty_StreamFormat:
            if (outDataSize) *outDataSize = sizeof(AudioStreamBasicDescription);
            if (outWritable) *outWritable = true;
            return noErr;

        // Sample rate
        case kAudioUnitProperty_SampleRate:
            if (outDataSize) *outDataSize = sizeof(Float64);
            if (outWritable) *outWritable = true;
            return noErr;

        // Maximum frames per slice
        case kAudioUnitProperty_MaximumFramesPerSlice:
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = true;
            return noErr;

        // Parameter list
        case kAudioUnitProperty_ParameterList:
            if (scope == kAudioUnitScope_Global && element == 0) {{
                uint32_t count = beamer_au_get_parameter_count(inst->rustInstance);
                if (outDataSize) *outDataSize = count * sizeof(AudioUnitParameterID);
                if (outWritable) *outWritable = false;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Parameter info (element is param ID)
        case kAudioUnitProperty_ParameterInfo:
            if (scope == kAudioUnitScope_Global) {{
                if (outDataSize) *outDataSize = sizeof(AudioUnitParameterInfo);
                if (outWritable) *outWritable = false;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Parameter value strings (for indexed params)
        case kAudioUnitProperty_ParameterValueStrings:
            if (scope == kAudioUnitScope_Global) {{
                uint32_t count = beamer_au_get_parameter_value_count(inst->rustInstance, element);
                if (count > 0) {{
                    if (outDataSize) *outDataSize = sizeof(CFArrayRef);
                    if (outWritable) *outWritable = false;
                    return noErr;
                }}
            }}
            return kAudioUnitErr_InvalidProperty;

        // Parameter string from value (convert value to display string)
        case kAudioUnitProperty_ParameterStringFromValue:
            if (scope == kAudioUnitScope_Global) {{
                if (outDataSize) *outDataSize = sizeof(AudioUnitParameterStringFromValue);
                if (outWritable) *outWritable = false;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Parameter value from string (convert display string to value)
        case kAudioUnitProperty_ParameterValueFromString:
            if (scope == kAudioUnitScope_Global) {{
                if (outDataSize) *outDataSize = sizeof(AudioUnitParameterValueFromString);
                if (outWritable) *outWritable = true;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Latency (Global scope only)
        case kAudioUnitProperty_Latency:
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (outDataSize) *outDataSize = sizeof(Float64);
            if (outWritable) *outWritable = false;
            return noErr;

        // Tail time (Global scope only)
        case kAudioUnitProperty_TailTime:
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (outDataSize) *outDataSize = sizeof(Float64);
            if (outWritable) *outWritable = false;
            return noErr;

        // Bypass (Global scope only)
        case kAudioUnitProperty_BypassEffect:
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = true;
            return noErr;

        // Present preset
        case kAudioUnitProperty_PresentPreset:
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (outDataSize) *outDataSize = sizeof(AUPreset);
            if (outWritable) *outWritable = true;
            return noErr;

        // Factory presets
        case kAudioUnitProperty_FactoryPresets:
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (outDataSize) *outDataSize = sizeof(CFArrayRef);
            if (outWritable) *outWritable = false;  // Factory presets are read-only
            return noErr;

        // Render callback (for setting input source)
        case kAudioUnitProperty_SetRenderCallback:
            if (scope == kAudioUnitScope_Input && element == 0) {{
                if (outDataSize) *outDataSize = sizeof(AURenderCallbackStruct);
                if (outWritable) *outWritable = true;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Audio unit connection
        case kAudioUnitProperty_MakeConnection:
            if (scope == kAudioUnitScope_Input && element == 0) {{
                if (outDataSize) *outDataSize = sizeof(AudioUnitConnection);
                if (outWritable) *outWritable = true;
                return noErr;
            }}
            return kAudioUnitErr_InvalidScope;

        // Supported channel layouts
        case kAudioUnitProperty_SupportedNumChannels:
            if (scope == kAudioUnitScope_Global) {{
                BeamerAuChannelCapabilities caps;
                if (beamer_au_get_channel_capabilities(inst->rustInstance, &caps)) {{
                    if (outDataSize) *outDataSize = caps.count * sizeof(AUChannelInfo);
                    if (outWritable) *outWritable = false;
                    return noErr;
                }}
            }}
            return kAudioUnitErr_InvalidProperty;

        // Class info (state save/restore)
        case kAudioUnitProperty_ClassInfo:
            if (outDataSize) *outDataSize = sizeof(CFPropertyListRef);
            if (outWritable) *outWritable = true;
            return noErr;

        // Host callbacks
        case kAudioUnitProperty_HostCallbacks:
            if (outDataSize) *outDataSize = sizeof(HostCallbackInfo);
            if (outWritable) *outWritable = true;
            return noErr;

        // Element count
        case kAudioUnitProperty_ElementCount:
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = false;
            return noErr;

        // In-place processing
        case kAudioUnitProperty_InPlaceProcessing:
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = true;
            return noErr;

        // Offline render
        case kAudioUnitProperty_OfflineRender:
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = true;
            return noErr;

        // Should allocate buffer
        case kAudioUnitProperty_ShouldAllocateBuffer:
            if (outDataSize) *outDataSize = sizeof(UInt32);
            if (outWritable) *outWritable = true;
            return noErr;

        // Last render error
        case kAudioUnitProperty_LastRenderError:
            if (outDataSize) *outDataSize = sizeof(OSStatus);
            if (outWritable) *outWritable = false;
            return noErr;

        default:
            return kAudioUnitErr_InvalidProperty;
    }}
}}

static OSStatus BeamerAuv2GetProperty(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, void* outData, UInt32* ioDataSize) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    switch (propID) {{
        case kAudioUnitProperty_StreamFormat: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(AudioStreamBasicDescription)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            AudioStreamBasicDescription* desc = (AudioStreamBasicDescription*)outData;
            if (scope == kAudioUnitScope_Input) {{
                *desc = inst->inputFormat;
            }} else if (scope == kAudioUnitScope_Output) {{
                *desc = inst->outputFormat;
            }} else {{
                return kAudioUnitErr_InvalidScope;
            }}
            *ioDataSize = sizeof(AudioStreamBasicDescription);
            return noErr;
        }}

        case kAudioUnitProperty_SampleRate: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(Float64)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            *(Float64*)outData = inst->sampleRate;
            *ioDataSize = sizeof(Float64);
            return noErr;
        }}

        case kAudioUnitProperty_MaximumFramesPerSlice: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            *(UInt32*)outData = inst->maxFramesPerSlice;
            *ioDataSize = sizeof(UInt32);
            return noErr;
        }}

        case kAudioUnitProperty_ParameterList: {{
            if (scope != kAudioUnitScope_Global || element != 0) {{
                return kAudioUnitErr_InvalidScope;
            }}
            uint32_t count = beamer_au_get_parameter_count(inst->rustInstance);
            UInt32 needed = count * sizeof(AudioUnitParameterID);
            if (!outData || !ioDataSize || *ioDataSize < needed) {{
                if (ioDataSize) *ioDataSize = needed;
                return outData ? kAudioUnitErr_InvalidPropertyValue : noErr;
            }}
            AudioUnitParameterID* ids = (AudioUnitParameterID*)outData;
            for (uint32_t i = 0; i < count; i++) {{
                BeamerAuParameterInfo info;
                if (beamer_au_get_parameter_info(inst->rustInstance, i, &info)) {{
                    ids[i] = info.id;
                }} else {{
                    ids[i] = 0;
                }}
            }}
            *ioDataSize = needed;
            return noErr;
        }}

        case kAudioUnitProperty_ParameterInfo: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(AudioUnitParameterInfo)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            // element is the parameter ID - find it by iterating
            uint32_t count = beamer_au_get_parameter_count(inst->rustInstance);
            for (uint32_t i = 0; i < count; i++) {{
                BeamerAuParameterInfo bInfo;
                if (beamer_au_get_parameter_info(inst->rustInstance, i, &bInfo) && bInfo.id == element) {{
                    AudioUnitParameterInfo* auInfo = (AudioUnitParameterInfo*)outData;
                    memset(auInfo, 0, sizeof(AudioUnitParameterInfo));

                    // Copy name (CFString)
                    auInfo->cfNameString = CFStringCreateWithCString(NULL, bInfo.name, kCFStringEncodingUTF8);
                    auInfo->flags = kAudioUnitParameterFlag_HasCFNameString |
                                    kAudioUnitParameterFlag_IsReadable |
                                    kAudioUnitParameterFlag_IsWritable;

                    if (bInfo.flags & BeamerAuParameterFlagAutomatable) {{
                        auInfo->flags |= kAudioUnitParameterFlag_IsHighResolution;
                    }}

                    // Map unit type
                    auInfo->unit = bInfo.unit_type;

                    // Use actual value range from Rust
                    auInfo->minValue = bInfo.min_value;
                    auInfo->maxValue = bInfo.max_value;
                    auInfo->defaultValue = bInfo.default_value;

                    // Check if indexed parameter (for value strings)
                    // AUv2 indexed params use integer values 0..step_count
                    if (bInfo.unit_type == kAudioUnitParameterUnit_Indexed && bInfo.step_count > 0) {{
                        auInfo->flags |= kAudioUnitParameterFlag_ValuesHaveStrings;
                        auInfo->maxValue = (float)bInfo.step_count;
                        // Convert default from normalized to index
                        auInfo->defaultValue = roundf(bInfo.default_value * (float)bInfo.step_count);
                    }}

                    // Copy unit label if present
                    if (bInfo.units[0] != '\0') {{
                        auInfo->unitName = CFStringCreateWithCString(NULL, bInfo.units, kCFStringEncodingUTF8);
                    }}

                    *ioDataSize = sizeof(AudioUnitParameterInfo);
                    return noErr;
                }}
            }}
            return kAudioUnitErr_InvalidParameter;
        }}

        case kAudioUnitProperty_ParameterValueStrings: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            uint32_t count = beamer_au_get_parameter_value_count(inst->rustInstance, element);
            if (count == 0) {{
                return kAudioUnitErr_InvalidProperty;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(CFArrayRef)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            CFMutableArrayRef array = CFArrayCreateMutable(NULL, count, &kCFTypeArrayCallBacks);
            char buffer[256];
            for (uint32_t i = 0; i < count; i++) {{
                if (beamer_au_get_parameter_value_string(inst->rustInstance, element, i, buffer, sizeof(buffer))) {{
                    CFStringRef str = CFStringCreateWithCString(NULL, buffer, kCFStringEncodingUTF8);
                    CFArrayAppendValue(array, str);
                    CFRelease(str);
                }}
            }}
            *(CFArrayRef*)outData = array;
            *ioDataSize = sizeof(CFArrayRef);
            return noErr;
        }}

        case kAudioUnitProperty_ParameterStringFromValue: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(AudioUnitParameterStringFromValue)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            AudioUnitParameterStringFromValue* params = (AudioUnitParameterStringFromValue*)outData;
            AudioUnitParameterID paramID = params->inParamID;

            // Get the value to convert (either provided or current)
            float value;
            if (params->inValue != NULL) {{
                value = *(params->inValue);
            }} else {{
                value = beamer_au_get_parameter_value_au(inst->rustInstance, paramID);
            }}

            // For indexed parameters, convert index to normalized for formatting
            float formatValue = value;
            uint32_t count = beamer_au_get_parameter_count(inst->rustInstance);
            for (uint32_t i = 0; i < count; i++) {{
                BeamerAuParameterInfo info;
                if (beamer_au_get_parameter_info(inst->rustInstance, i, &info) && info.id == paramID) {{
                    if (info.unit_type == kAudioUnitParameterUnit_Indexed && info.step_count > 0) {{
                        formatValue = value / (float)info.step_count;
                    }}
                    break;
                }}
            }}

            char buffer[256];
            uint32_t written = beamer_au_format_parameter_value(inst->rustInstance, paramID, formatValue, buffer, sizeof(buffer));
            if (written > 0) {{
                params->outString = CFStringCreateWithCString(NULL, buffer, kCFStringEncodingUTF8);
            }} else {{
                // Fallback: format as number
                char fallback[64];
                snprintf(fallback, sizeof(fallback), "%.2f", value);
                params->outString = CFStringCreateWithCString(NULL, fallback, kCFStringEncodingUTF8);
            }}

            *ioDataSize = sizeof(AudioUnitParameterStringFromValue);
            return noErr;
        }}

        case kAudioUnitProperty_ParameterValueFromString: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(AudioUnitParameterValueFromString)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            AudioUnitParameterValueFromString* params = (AudioUnitParameterValueFromString*)outData;
            AudioUnitParameterID paramID = params->inParamID;
            CFStringRef inputString = params->inString;

            if (inputString == NULL) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            char buffer[256];
            if (!CFStringGetCString(inputString, buffer, sizeof(buffer), kCFStringEncodingUTF8)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            float parsedValue = 0.0f;
            if (beamer_au_parse_parameter_value(inst->rustInstance, paramID, buffer, &parsedValue)) {{
                // For indexed parameters, convert normalized to index
                uint32_t count = beamer_au_get_parameter_count(inst->rustInstance);
                for (uint32_t i = 0; i < count; i++) {{
                    BeamerAuParameterInfo info;
                    if (beamer_au_get_parameter_info(inst->rustInstance, i, &info) && info.id == paramID) {{
                        if (info.unit_type == kAudioUnitParameterUnit_Indexed && info.step_count > 0) {{
                            parsedValue = roundf(parsedValue * (float)info.step_count);
                        }}
                        break;
                    }}
                }}
                params->outValue = parsedValue;
            }} else {{
                // Parsing failed, try to interpret as a number directly
                params->outValue = (float)atof(buffer);
            }}

            *ioDataSize = sizeof(AudioUnitParameterValueFromString);
            return noErr;
        }}

        case kAudioUnitProperty_Latency: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(Float64)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            uint32_t samples = beamer_au_get_latency_samples(inst->rustInstance);
            *(Float64*)outData = (inst->sampleRate > 0) ? (Float64)samples / inst->sampleRate : 0.0;
            *ioDataSize = sizeof(Float64);
            return noErr;
        }}

        case kAudioUnitProperty_TailTime: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(Float64)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            uint32_t samples = beamer_au_get_tail_samples(inst->rustInstance);
            if (samples == UINT32_MAX) {{
                *(Float64*)outData = INFINITY;
            }} else {{
                *(Float64*)outData = (inst->sampleRate > 0) ? (Float64)samples / inst->sampleRate : 0.0;
            }}
            *ioDataSize = sizeof(Float64);
            return noErr;
        }}

        case kAudioUnitProperty_BypassEffect: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            *(UInt32*)outData = inst->bypassed ? 1 : 0;
            *ioDataSize = sizeof(UInt32);
            return noErr;
        }}

        case kAudioUnitProperty_SupportedNumChannels: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            BeamerAuChannelCapabilities caps;
            if (!beamer_au_get_channel_capabilities(inst->rustInstance, &caps)) {{
                return kAudioUnitErr_InvalidProperty;
            }}
            UInt32 needed = caps.count * sizeof(AUChannelInfo);
            if (!outData || !ioDataSize || *ioDataSize < needed) {{
                if (ioDataSize) *ioDataSize = needed;
                return outData ? kAudioUnitErr_InvalidPropertyValue : noErr;
            }}
            AUChannelInfo* info = (AUChannelInfo*)outData;
            for (uint32_t i = 0; i < caps.count; i++) {{
                info[i].inChannels = (SInt16)caps.capabilities[i].input_channels;
                info[i].outChannels = (SInt16)caps.capabilities[i].output_channels;
            }}
            *ioDataSize = needed;
            return noErr;
        }}

        case kAudioUnitProperty_ClassInfo: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(CFPropertyListRef)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            // Get component description for type/subtype/manufacturer
            AudioComponentDescription desc;
            beamer_au_get_component_description(&desc);

            CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0,
                &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

            // Add required type/subtype/manufacturer fields
            SInt32 compType = (SInt32)desc.componentType;
            SInt32 compSubType = (SInt32)desc.componentSubType;
            SInt32 compManu = (SInt32)desc.componentManufacturer;
            CFNumberRef typeNum = CFNumberCreate(NULL, kCFNumberSInt32Type, &compType);
            CFNumberRef subTypeNum = CFNumberCreate(NULL, kCFNumberSInt32Type, &compSubType);
            CFNumberRef manuNum = CFNumberCreate(NULL, kCFNumberSInt32Type, &compManu);
            CFDictionarySetValue(dict, CFSTR("type"), typeNum);
            CFDictionarySetValue(dict, CFSTR("subtype"), subTypeNum);
            CFDictionarySetValue(dict, CFSTR("manufacturer"), manuNum);
            CFRelease(typeNum);
            CFRelease(subTypeNum);
            CFRelease(manuNum);

            // Add plugin name
            char nameBuffer[256];
            uint32_t nameLen = beamer_au_get_name(inst->rustInstance, nameBuffer, sizeof(nameBuffer));
            if (nameLen > 0) {{
                CFStringRef nameStr = CFStringCreateWithCString(NULL, nameBuffer, kCFStringEncodingUTF8);
                CFDictionarySetValue(dict, CFSTR("name"), nameStr);
                CFRelease(nameStr);
            }}

            // Store format version
            SInt32 version = 0;
            CFNumberRef versionNum = CFNumberCreate(NULL, kCFNumberSInt32Type, &version);
            CFDictionarySetValue(dict, CFSTR("version"), versionNum);
            CFRelease(versionNum);

            // Get state from Rust (save as "data" key which is the standard AU key)
            uint32_t stateSize = beamer_au_get_state_size(inst->rustInstance);
            if (stateSize > 0) {{
                uint8_t* stateBuffer = (uint8_t*)malloc(stateSize);
                if (stateBuffer) {{
                    uint32_t written = beamer_au_get_state(inst->rustInstance, stateBuffer, stateSize);
                    if (written > 0) {{
                        CFDataRef data = CFDataCreate(NULL, stateBuffer, written);
                        CFDictionarySetValue(dict, CFSTR("data"), data);
                        CFRelease(data);
                    }}
                    free(stateBuffer);
                }}
            }}

            *(CFPropertyListRef*)outData = dict;
            *ioDataSize = sizeof(CFPropertyListRef);
            return noErr;
        }}

        case kAudioUnitProperty_ElementCount: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            if (scope == kAudioUnitScope_Input) {{
                *(UInt32*)outData = beamer_au_get_input_bus_count(inst->rustInstance);
            }} else if (scope == kAudioUnitScope_Output) {{
                *(UInt32*)outData = beamer_au_get_output_bus_count(inst->rustInstance);
            }} else if (scope == kAudioUnitScope_Global) {{
                *(UInt32*)outData = 1;
            }} else {{
                return kAudioUnitErr_InvalidScope;
            }}
            *ioDataSize = sizeof(UInt32);
            return noErr;
        }}

        case kAudioUnitProperty_InPlaceProcessing: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            *(UInt32*)outData = 0; // Not using in-place processing
            *ioDataSize = sizeof(UInt32);
            return noErr;
        }}

        case kAudioUnitProperty_PresentPreset: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(AUPreset)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            AUPreset* preset = (AUPreset*)outData;
            if (inst->currentPresetIndex >= 0 && (uint32_t)inst->currentPresetIndex < inst->presetCount && inst->presetStorage) {{
                preset->presetNumber = inst->presetStorage[inst->currentPresetIndex].presetNumber;
                preset->presetName = inst->presetStorage[inst->currentPresetIndex].presetName;
            }} else {{
                preset->presetNumber = -1;
                preset->presetName = CFSTR("Current Settings");
            }}
            *ioDataSize = sizeof(AUPreset);
            return noErr;
        }}

        case kAudioUnitProperty_FactoryPresets: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!outData || !ioDataSize || *ioDataSize < sizeof(CFArrayRef)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            if (inst->factoryPresets) {{
                CFRetain(inst->factoryPresets);  // Caller owns reference
                *(CFArrayRef*)outData = inst->factoryPresets;
            }} else {{
                *(CFArrayRef*)outData = NULL;
            }}
            *ioDataSize = sizeof(CFArrayRef);
            return noErr;
        }}

        case kAudioUnitProperty_LastRenderError: {{
            if (!outData || !ioDataSize || *ioDataSize < sizeof(OSStatus)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            *(OSStatus*)outData = noErr;
            *ioDataSize = sizeof(OSStatus);
            return noErr;
        }}

        default:
            return kAudioUnitErr_InvalidProperty;
    }}
}}

static OSStatus BeamerAuv2SetProperty(void* self, AudioUnitPropertyID propID,
    AudioUnitScope scope, AudioUnitElement element, const void* inData, UInt32 inDataSize) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    switch (propID) {{
        case kAudioUnitProperty_StreamFormat: {{
            if (!inData || inDataSize < sizeof(AudioStreamBasicDescription)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            const AudioStreamBasicDescription* desc = (const AudioStreamBasicDescription*)inData;

            // Validate format (must be float, non-interleaved)
            if (desc->mFormatID != kAudioFormatLinearPCM) {{
                return kAudioUnitErr_FormatNotSupported;
            }}
            if (!(desc->mFormatFlags & kAudioFormatFlagIsFloat)) {{
                return kAudioUnitErr_FormatNotSupported;
            }}

            // Validate scope first
            if (scope != kAudioUnitScope_Input && scope != kAudioUnitScope_Output) {{
                return kAudioUnitErr_InvalidScope;
            }}

            // Validate channel count is reasonable (1-64 channels)
            UInt32 proposedChannels = desc->mChannelsPerFrame;
            if (proposedChannels == 0 || proposedChannels > 64) {{
                return kAudioUnitErr_FormatNotSupported;
            }}

            // Validate channel count against declared capability for MAIN bus (element 0).
            // This enforces the [N, M] capability we report in SupportedNumChannels.
            // Auxiliary buses (sidechain, etc.) can have any reasonable channel count.
            if (element == 0) {{
                uint32_t declaredChannels;
                if (scope == kAudioUnitScope_Input) {{
                    declaredChannels = beamer_au_get_input_bus_channel_count(inst->rustInstance, 0);
                }} else {{
                    declaredChannels = beamer_au_get_output_bus_channel_count(inst->rustInstance, 0);
                }}
                if (declaredChannels > 0 && proposedChannels != declaredChannels) {{
                    return kAudioUnitErr_FormatNotSupported;
                }}
            }}

            // Apply the format change
            if (scope == kAudioUnitScope_Input) {{
                inst->inputFormat = *desc;
            }} else {{
                inst->outputFormat = *desc;
            }}
            inst->sampleRate = desc->mSampleRate;

            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_SampleRate: {{
            if (!inData || inDataSize < sizeof(Float64)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            inst->sampleRate = *(Float64*)inData;
            inst->inputFormat.mSampleRate = inst->sampleRate;
            inst->outputFormat.mSampleRate = inst->sampleRate;
            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_MaximumFramesPerSlice: {{
            if (!inData || inDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            inst->maxFramesPerSlice = *(UInt32*)inData;
            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_BypassEffect: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!inData || inDataSize < sizeof(UInt32)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            inst->bypassed = (*(UInt32*)inData != 0);
            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_SetRenderCallback: {{
            if (scope != kAudioUnitScope_Input || element != 0) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!inData || inDataSize < sizeof(AURenderCallbackStruct)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            inst->inputCallback = *(AURenderCallbackStruct*)inData;
            // Clear connection when callback is set
            inst->inputConnection.sourceAU = NULL;
            return noErr;
        }}

        case kAudioUnitProperty_MakeConnection: {{
            if (scope != kAudioUnitScope_Input || element != 0) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!inData || inDataSize < sizeof(AudioUnitConnection)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            const AudioUnitConnection* conn = (const AudioUnitConnection*)inData;
            inst->inputConnection.sourceAU = conn->sourceAudioUnit;
            inst->inputConnection.sourceOutputNumber = conn->sourceOutputNumber;
            // Clear callback when connection is set
            inst->inputCallback.inputProc = NULL;
            inst->inputCallback.inputProcRefCon = NULL;
            return noErr;
        }}

        case kAudioUnitProperty_HostCallbacks: {{
            if (!inData || inDataSize < sizeof(HostCallbackInfo)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            inst->hostCallbacks = *(HostCallbackInfo*)inData;
            return noErr;
        }}

        case kAudioUnitProperty_ClassInfo: {{
            if (!inData || inDataSize < sizeof(CFPropertyListRef)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}
            CFDictionaryRef dict = *(CFDictionaryRef*)inData;
            if (!dict || CFGetTypeID(dict) != CFDictionaryGetTypeID()) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            // Try "data" key (standard AU) first, then fallback to "beamer-state"
            CFDataRef stateData = (CFDataRef)CFDictionaryGetValue(dict, CFSTR("data"));
            if (!stateData) {{
                stateData = (CFDataRef)CFDictionaryGetValue(dict, CFSTR("beamer-state"));
            }}
            if (stateData && CFGetTypeID(stateData) == CFDataGetTypeID()) {{
                const uint8_t* bytes = CFDataGetBytePtr(stateData);
                CFIndex length = CFDataGetLength(stateData);
                beamer_au_set_state(inst->rustInstance, bytes, (uint32_t)length);
            }}

            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_PresentPreset: {{
            if (scope != kAudioUnitScope_Global) {{
                return kAudioUnitErr_InvalidScope;
            }}
            if (!inData || inDataSize < sizeof(AUPreset)) {{
                return kAudioUnitErr_InvalidPropertyValue;
            }}

            const AUPreset* newPreset = (const AUPreset*)inData;
            if (newPreset->presetNumber >= 0 && (uint32_t)newPreset->presetNumber < inst->presetCount) {{
                inst->currentPresetIndex = newPreset->presetNumber;
                beamer_au_apply_preset(inst->rustInstance, (uint32_t)newPreset->presetNumber);
            }} else {{
                // User preset (negative number) - just track the index
                inst->currentPresetIndex = -1;
            }}

            NotifyPropertyListeners(inst, propID, scope, element);
            return noErr;
        }}

        case kAudioUnitProperty_OfflineRender:
        case kAudioUnitProperty_InPlaceProcessing:
        case kAudioUnitProperty_ShouldAllocateBuffer:
            // Accept but ignore these
            return noErr;

        default:
            return kAudioUnitErr_InvalidProperty;
    }}
}}

// =============================================================================
// MARK: - Property Listeners
// =============================================================================

static OSStatus BeamerAuv2AddPropertyListener(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc, void* userData) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    pthread_mutex_lock(&inst->listenerMutex);
    if (inst->propertyListenerCount >= MAX_PROPERTY_LISTENERS) {{
        pthread_mutex_unlock(&inst->listenerMutex);
        return kAudio_TooManyFilesOpenError;
    }}

    PropertyListener* listener = &inst->propertyListeners[inst->propertyListenerCount++];
    listener->propID = propID;
    listener->proc = proc;
    listener->userData = userData;

    pthread_mutex_unlock(&inst->listenerMutex);
    return noErr;
}}

static OSStatus BeamerAuv2RemovePropertyListener(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    pthread_mutex_lock(&inst->listenerMutex);
    for (UInt32 i = 0; i < inst->propertyListenerCount; i++) {{
        if (inst->propertyListeners[i].propID == propID && inst->propertyListeners[i].proc == proc) {{
            // Shift remaining listeners down
            for (UInt32 j = i; j < inst->propertyListenerCount - 1; j++) {{
                inst->propertyListeners[j] = inst->propertyListeners[j + 1];
            }}
            inst->propertyListenerCount--;
            pthread_mutex_unlock(&inst->listenerMutex);
            return noErr;
        }}
    }}
    pthread_mutex_unlock(&inst->listenerMutex);
    return noErr;
}}

static OSStatus BeamerAuv2RemovePropertyListenerWithUserData(void* self, AudioUnitPropertyID propID,
    AudioUnitPropertyListenerProc proc, void* userData) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    pthread_mutex_lock(&inst->listenerMutex);
    for (UInt32 i = 0; i < inst->propertyListenerCount; i++) {{
        if (inst->propertyListeners[i].propID == propID &&
            inst->propertyListeners[i].proc == proc &&
            inst->propertyListeners[i].userData == userData) {{
            // Shift remaining listeners down
            for (UInt32 j = i; j < inst->propertyListenerCount - 1; j++) {{
                inst->propertyListeners[j] = inst->propertyListeners[j + 1];
            }}
            inst->propertyListenerCount--;
            pthread_mutex_unlock(&inst->listenerMutex);
            return noErr;
        }}
    }}
    pthread_mutex_unlock(&inst->listenerMutex);
    return noErr;
}}

// =============================================================================
// MARK: - Parameters
// =============================================================================

static OSStatus BeamerAuv2GetParameter(void* self, AudioUnitParameterID paramID,
    AudioUnitScope scope, AudioUnitElement element, AudioUnitParameterValue* outValue) {{

    (void)element;

    if (scope != kAudioUnitScope_Global) {{
        return kAudioUnitErr_InvalidScope;
    }}

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;
    // Use AU-format getter which handles indexed parameter conversion internally
    *outValue = beamer_au_get_parameter_value_au(inst->rustInstance, paramID);
    return noErr;
}}

static OSStatus BeamerAuv2SetParameter(void* self, AudioUnitParameterID paramID,
    AudioUnitScope scope, AudioUnitElement element, AudioUnitParameterValue value, UInt32 bufferOffset) {{

    (void)element;
    (void)bufferOffset; // TODO: Support sample-accurate automation

    if (scope != kAudioUnitScope_Global) {{
        return kAudioUnitErr_InvalidScope;
    }}

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;
    // Use AU-format setter which handles indexed parameter conversion internally
    beamer_au_set_parameter_value_au(inst->rustInstance, paramID, value);
    return noErr;
}}

static OSStatus BeamerAuv2ScheduleParameters(void* self, const AudioUnitParameterEvent* events, UInt32 numEvents) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    for (UInt32 i = 0; i < numEvents; i++) {{
        const AudioUnitParameterEvent* event = &events[i];
        if (event->eventType == kParameterEvent_Immediate) {{
            // Use AU-format setter which handles indexed parameter conversion internally
            beamer_au_set_parameter_value_au(inst->rustInstance, event->parameter,
                event->eventValues.immediate.value);
        }}
        // TODO: Handle ramped parameter changes
    }}

    return noErr;
}}

// =============================================================================
// MARK: - Render
// =============================================================================

static OSStatus BeamerAuv2Render(void* self, AudioUnitRenderActionFlags* ioActionFlags,
    const AudioTimeStamp* inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList* ioData) {{

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    if (!inst->initialized) {{
        return kAudioUnitErr_Uninitialized;
    }}

    if (inNumberFrames > inst->maxFramesPerSlice) {{
        return kAudioUnitErr_TooManyFramesToProcess;
    }}

    // Call pre-render notifications
    pthread_mutex_lock(&inst->renderNotifyMutex);
    for (UInt32 i = 0; i < inst->renderNotifyCount; i++) {{
        AudioUnitRenderActionFlags preFlags = kAudioUnitRenderAction_PreRender;
        inst->renderNotify[i].proc(inst->renderNotify[i].userData,
            &preFlags, inTimeStamp, inOutputBusNumber, inNumberFrames, ioData);
    }}
    pthread_mutex_unlock(&inst->renderNotifyMutex);

    // Handle bypass
    if (inst->bypassed) {{
        // For bypass, we need to copy input to output
        // Pull input first
        AudioBufferList* inputData = NULL;
        if (inst->inputCallback.inputProc) {{
            EnsureInputBufferList(inst, inst->inputFormat.mChannelsPerFrame, inNumberFrames);
            AudioUnitRenderActionFlags pullFlags = 0;
            OSStatus pullStatus = inst->inputCallback.inputProc(
                inst->inputCallback.inputProcRefCon,
                &pullFlags, inTimeStamp, 0, inNumberFrames, inst->inputBufferList);
            if (pullStatus == noErr) {{
                inputData = inst->inputBufferList;
            }}
        }} else if (inst->inputConnection.sourceAU) {{
            EnsureInputBufferList(inst, inst->inputFormat.mChannelsPerFrame, inNumberFrames);
            AudioUnitRenderActionFlags pullFlags = 0;
            OSStatus pullStatus = AudioUnitRender(inst->inputConnection.sourceAU,
                &pullFlags, inTimeStamp, inst->inputConnection.sourceOutputNumber,
                inNumberFrames, inst->inputBufferList);
            if (pullStatus == noErr) {{
                inputData = inst->inputBufferList;
            }}
        }}

        // Copy input to output for bypass
        if (inputData) {{
            UInt32 buffersToCopy = (inputData->mNumberBuffers < ioData->mNumberBuffers) ?
                inputData->mNumberBuffers : ioData->mNumberBuffers;
            for (UInt32 i = 0; i < buffersToCopy; i++) {{
                UInt32 bytesToCopy = (inputData->mBuffers[i].mDataByteSize < ioData->mBuffers[i].mDataByteSize) ?
                    inputData->mBuffers[i].mDataByteSize : ioData->mBuffers[i].mDataByteSize;
                memcpy(ioData->mBuffers[i].mData, inputData->mBuffers[i].mData, bytesToCopy);
            }}
        }} else {{
            // No input, silence output
            for (UInt32 i = 0; i < ioData->mNumberBuffers; i++) {{
                memset(ioData->mBuffers[i].mData, 0, ioData->mBuffers[i].mDataByteSize);
            }}
        }}

        // Call post-render notifications
        pthread_mutex_lock(&inst->renderNotifyMutex);
        for (UInt32 i = 0; i < inst->renderNotifyCount; i++) {{
            AudioUnitRenderActionFlags postFlags = kAudioUnitRenderAction_PostRender;
            inst->renderNotify[i].proc(inst->renderNotify[i].userData,
                &postFlags, inTimeStamp, inOutputBusNumber, inNumberFrames, ioData);
        }}
        pthread_mutex_unlock(&inst->renderNotifyMutex);

        return noErr;
    }}

    // Pull input audio
    AudioBufferList* inputData = NULL;
    uint32_t inputBusCount = beamer_au_get_input_bus_count(inst->rustInstance);

    if (inputBusCount > 0) {{
        if (inst->inputCallback.inputProc) {{
            EnsureInputBufferList(inst, inst->inputFormat.mChannelsPerFrame, inNumberFrames);
            AudioUnitRenderActionFlags pullFlags = 0;
            OSStatus pullStatus = inst->inputCallback.inputProc(
                inst->inputCallback.inputProcRefCon,
                &pullFlags, inTimeStamp, 0, inNumberFrames, inst->inputBufferList);
            if (pullStatus == noErr) {{
                inputData = inst->inputBufferList;
            }}
        }} else if (inst->inputConnection.sourceAU) {{
            EnsureInputBufferList(inst, inst->inputFormat.mChannelsPerFrame, inNumberFrames);
            AudioUnitRenderActionFlags pullFlags = 0;
            OSStatus pullStatus = AudioUnitRender(inst->inputConnection.sourceAU,
                &pullFlags, inTimeStamp, inst->inputConnection.sourceOutputNumber,
                inNumberFrames, inst->inputBufferList);
            if (pullStatus == noErr) {{
                inputData = inst->inputBufferList;
            }}
        }}
    }}

    // Call Rust render function
    // Note: AUv2 doesn't have AURenderEvent, so we pass NULL for events and blocks
    OSStatus status = beamer_au_render(
        inst->rustInstance,
        ioActionFlags,
        inTimeStamp,
        inNumberFrames,
        inOutputBusNumber,
        ioData,
        NULL,  // events (AUv2 doesn't use AURenderEvent linked list)
        NULL,  // pull_input_block (we pre-pulled via callback/connection)
        inputData,
        NULL,  // musical_context_block (TODO: wrap host callbacks)
        NULL,  // transport_state_block (TODO: wrap host callbacks)
        NULL   // schedule_midi_block
    );

    // Call post-render notifications
    pthread_mutex_lock(&inst->renderNotifyMutex);
    for (UInt32 i = 0; i < inst->renderNotifyCount; i++) {{
        AudioUnitRenderActionFlags postFlags = kAudioUnitRenderAction_PostRender;
        inst->renderNotify[i].proc(inst->renderNotify[i].userData,
            &postFlags, inTimeStamp, inOutputBusNumber, inNumberFrames, ioData);
    }}
    pthread_mutex_unlock(&inst->renderNotifyMutex);

    return status;
}}

// =============================================================================
// MARK: - Reset
// =============================================================================

static OSStatus BeamerAuv2Reset(void* self, AudioUnitScope scope, AudioUnitElement element) {{
    (void)scope;
    (void)element;

    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;
    beamer_au_reset(inst->rustInstance);
    return noErr;
}}

// =============================================================================
// MARK: - Render Notifications
// =============================================================================

static OSStatus BeamerAuv2AddRenderNotify(void* self, AURenderCallback proc, void* userData) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    pthread_mutex_lock(&inst->renderNotifyMutex);
    if (inst->renderNotifyCount >= MAX_RENDER_NOTIFY) {{
        pthread_mutex_unlock(&inst->renderNotifyMutex);
        return kAudio_TooManyFilesOpenError;
    }}

    inst->renderNotify[inst->renderNotifyCount].proc = proc;
    inst->renderNotify[inst->renderNotifyCount].userData = userData;
    inst->renderNotifyCount++;

    pthread_mutex_unlock(&inst->renderNotifyMutex);
    return noErr;
}}

static OSStatus BeamerAuv2RemoveRenderNotify(void* self, AURenderCallback proc, void* userData) {{
    BeamerAuv2Instance* inst = (BeamerAuv2Instance*)self;

    pthread_mutex_lock(&inst->renderNotifyMutex);
    for (UInt32 i = 0; i < inst->renderNotifyCount; i++) {{
        if (inst->renderNotify[i].proc == proc && inst->renderNotify[i].userData == userData) {{
            // Shift remaining entries down
            for (UInt32 j = i; j < inst->renderNotifyCount - 1; j++) {{
                inst->renderNotify[j] = inst->renderNotify[j + 1];
            }}
            inst->renderNotifyCount--;
            pthread_mutex_unlock(&inst->renderNotifyMutex);
            return noErr;
        }}
    }}
    pthread_mutex_unlock(&inst->renderNotifyMutex);
    return noErr;
}}
"#,
        plugin_name = plugin_name,
        factory_name = factory_name
    )
}

/// Generate the AU extension ObjC implementation with plugin-specific class names.
/// The extension class implements AUAudioUnitFactory protocol for AU instantiation.
fn generate_au_extension_source(plugin_name: &str) -> String {
    let pascal_name = to_pascal_case(plugin_name);
    let wrapper_class = format!("Beamer{}AuWrapper", pascal_name);
    let extension_class = format!("Beamer{}AuExtension", pascal_name);
    let factory_func = format!("Beamer{}AuExtensionFactory", pascal_name);

    format!(r#"// Auto-generated AU extension for {plugin_name}
// DO NOT EDIT - Generated by xtask

@import AudioToolbox;
@import Foundation;
#include "BeamerAuBridge.h"

@class {wrapper_class};

@interface {wrapper_class} : AUAudioUnit
- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError;
@end

// Extension class implementing AUAudioUnitFactory protocol.
// NSExtensionMain instantiates this class based on NSExtensionPrincipalClass in Info.plist.
@interface {extension_class} : NSObject <AUAudioUnitFactory>
@end

@implementation {extension_class}

// Required by NSExtensionRequestHandling protocol, but not used for AUv3.
// NSExtensionMain calls createAudioUnitWithComponentDescription:error: directly.
- (void)beginRequestWithExtensionContext:(NSExtensionContext *)context {{
    (void)context;
}}

- (AUAudioUnit *)createAudioUnitWithComponentDescription:(AudioComponentDescription)desc
                                                   error:(NSError **)error {{
    if (!beamer_au_ensure_factory_registered()) {{
        if (error) {{
            *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                         code:kAudioUnitErr_FailedInitialization
                                     userInfo:@{{NSLocalizedDescriptionKey: @"Failed to register plugin factory"}}];
        }}
        return nil;
    }}

    return [[{wrapper_class} alloc] initWithComponentDescription:desc options:0 error:error];
}}

@end

// Generic force_link function called by Rust code to ensure ObjC classes are linked.
// This is internal to each plugin's dylib, so no symbol collision occurs.
void beamer_au_appex_force_link(void) {{
    (void)[{extension_class} class];
}}

void* {factory_func}(const AudioComponentDescription* desc) {{
    if (!beamer_au_ensure_factory_registered()) {{
        return NULL;
    }}
    NSError* error = nil;
    {wrapper_class}* wrapper = [[{wrapper_class} alloc] initWithComponentDescription:*desc
                                                                             options:0
                                                                               error:&error];
    if (error) {{
        return NULL;
    }}
    return (__bridge_retained void*)wrapper;
}}
"#, plugin_name = plugin_name,
    wrapper_class = wrapper_class,
    extension_class = extension_class,
    factory_func = factory_func)
}

/// Generate appex_stub.m for the plugin.
/// This is a minimal stub - the actual entry point is NSExtensionMain (via -e linker flag).
/// The framework link in the clang command ensures the framework is loaded.
fn generate_appex_stub_source(plugin_name: &str) -> String {
    format!(r#"// Auto-generated appex stub for {plugin_name}
// DO NOT EDIT - Generated by xtask
//
// This file does NOT contain main(). The entry point is NSExtensionMain,
// which is set via the -e _NSExtensionMain linker flag. NSExtensionMain
// handles all XPC setup for app extensions automatically.
//
// The framework is linked via -framework flag, which ensures it's loaded.
// NSExtensionMain reads NSExtensionPrincipalClass from Info.plist and
// instantiates the extension class from the framework.

#import <Foundation/Foundation.h>

// Minimal stub - just needs to compile to create an object file.
// The -framework link ensures our AU framework is loaded at runtime.
"#, plugin_name = plugin_name)
}

/// Generate and compile plugin-specific ObjC code.
///
/// This creates uniquely named ObjC classes for each plugin to avoid symbol collisions
/// when multiple AU plugins are loaded in the same process (e.g., in Reaper).
///
/// Returns the path to the directory containing the compiled static libraries.
fn compile_plugin_objc(
    plugin_name: &str,
    workspace_root: &Path,
    target: &str,
) -> Result<PathBuf, String> {
    let lib_name = plugin_name.replace('-', "_");

    // Create output directory for generated sources and compiled libraries
    let gen_dir = workspace_root
        .join("target")
        .join("au-gen")
        .join(plugin_name)
        .join(target);

    fs::create_dir_all(&gen_dir)
        .map_err(|e| format!("Failed to create au-gen directory: {}", e))?;

    // Generate plugin-specific ObjC source files
    let wrapper_source = generate_au_wrapper_source(plugin_name);
    let extension_source = generate_au_extension_source(plugin_name);

    let wrapper_path = gen_dir.join("AuWrapper.m");
    let extension_path = gen_dir.join("AuExtension.m");

    fs::write(&wrapper_path, wrapper_source)
        .map_err(|e| format!("Failed to write AuWrapper.m: {}", e))?;
    fs::write(&extension_path, extension_source)
        .map_err(|e| format!("Failed to write AuExtension.m: {}", e))?;

    // Path to BeamerAuBridge.h header
    let bridge_header_dir = workspace_root.join("crates/beamer-au/objc");

    // Determine architecture for clang
    let arch = match target {
        "x86_64-apple-darwin" => "x86_64",
        "aarch64-apple-darwin" => "arm64",
        _ => return Err(format!("Unsupported target: {}", target)),
    };

    // Compile AuWrapper.m to static library
    let wrapper_obj = gen_dir.join("AuWrapper.o");
    let wrapper_lib = gen_dir.join(format!("lib{}_au_objc.a", lib_name));

    let status = Command::new("clang")
        .args([
            "-c",
            "-arch", arch,
            "-fobjc-arc",
            "-fmodules",
            "-I", bridge_header_dir.to_str().unwrap(),
            "-o", wrapper_obj.to_str().unwrap(),
            wrapper_path.to_str().unwrap(),
        ])
        .status()
        .map_err(|e| format!("Failed to compile AuWrapper.m: {}", e))?;

    if !status.success() {
        return Err("Failed to compile AuWrapper.m".to_string());
    }

    // Create static library from object file
    let status = Command::new("ar")
        .args(["rcs", wrapper_lib.to_str().unwrap(), wrapper_obj.to_str().unwrap()])
        .status()
        .map_err(|e| format!("Failed to create static library: {}", e))?;

    if !status.success() {
        return Err("Failed to create AuWrapper static library".to_string());
    }

    // Compile AuExtension.m to static library
    let extension_obj = gen_dir.join("AuExtension.o");
    let extension_lib = gen_dir.join(format!("lib{}_au_extension.a", lib_name));

    let status = Command::new("clang")
        .args([
            "-c",
            "-arch", arch,
            "-fobjc-arc",
            "-fmodules",
            "-I", bridge_header_dir.to_str().unwrap(),
            "-o", extension_obj.to_str().unwrap(),
            extension_path.to_str().unwrap(),
        ])
        .status()
        .map_err(|e| format!("Failed to compile AuExtension.m: {}", e))?;

    if !status.success() {
        return Err("Failed to compile AuExtension.m".to_string());
    }

    let status = Command::new("ar")
        .args(["rcs", extension_lib.to_str().unwrap(), extension_obj.to_str().unwrap()])
        .status()
        .map_err(|e| format!("Failed to create static library: {}", e))?;

    if !status.success() {
        return Err("Failed to create AuExtension static library".to_string());
    }

    // Clean up object files
    let _ = fs::remove_file(&wrapper_obj);
    let _ = fs::remove_file(&extension_obj);

    Ok(gen_dir)
}

/// Read version from workspace Cargo.toml and convert to Apple's version integer format
fn get_version_info(workspace_root: &Path) -> Result<(String, u32), String> {
    let cargo_toml_path = workspace_root.join("Cargo.toml");
    let cargo_toml = fs::read_to_string(&cargo_toml_path)
        .map_err(|e| format!("Failed to read Cargo.toml: {}", e))?;

    // Parse version from workspace.package.version
    let version = cargo_toml
        .lines()
        .skip_while(|line| !line.contains("[workspace.package]"))
        .skip(1)
        .find(|line| line.trim().starts_with("version"))
        .and_then(|line| line.split('=').nth(1))
        .map(|v| v.trim().trim_matches('"').to_string())
        .ok_or("Could not find version in Cargo.toml")?;

    // Parse version into major.minor.patch
    let parts: Vec<&str> = version.split('.').collect();
    if parts.len() < 3 {
        return Err(format!("Invalid version format: {}", version));
    }

    let major: u32 = parts[0].parse().map_err(|_| "Invalid major version")?;
    let minor: u32 = parts[1].parse().map_err(|_| "Invalid minor version")?;
    let patch: u32 = parts[2].parse().map_err(|_| "Invalid patch version")?;

    // Convert to Apple's version format: (major << 16) | (minor << 8) | patch
    let version_int = (major << 16) | (minor << 8) | patch;

    Ok((version, version_int))
}

fn main() {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 3 || args[1] != "bundle" {
        print_usage();
        std::process::exit(1);
    }

    let package = &args[2];
    let release = args.iter().any(|a| a == "--release");
    let install = args.iter().any(|a| a == "--install");
    let clean = args.iter().any(|a| a == "--clean");
    let verbose = args.iter().any(|a| a == "--verbose" || a == "-v");
    let build_vst3 = args.iter().any(|a| a == "--vst3");
    let build_auv2 = args.iter().any(|a| a == "--auv2");
    let build_auv3 = args.iter().any(|a| a == "--auv3");

    // Parse --arch flag
    let arch = args.windows(2)
        .find(|w| w[0] == "--arch")
        .map(|w| {
            Arch::from_str(&w[1]).unwrap_or_else(|| {
                eprintln!("Warning: unrecognized arch '{}', using native", w[1]);
                Arch::Native
            })
        })
        .unwrap_or(Arch::Native);

    // Check for unknown flags
    let known_flags = ["--release", "--install", "--clean", "--verbose", "-v", "--vst3", "--auv2", "--auv3", "--arch"];
    let arch_values = ["native", "universal", "arm64", "x86_64"];
    for arg in args.iter().skip(3) {
        if arg.starts_with('-') && !known_flags.contains(&arg.as_str()) {
            print_error(&format!("unknown flag '{}'", arg));
            eprintln!("Known flags: {}", known_flags.join(", "));
            std::process::exit(1);
        } else if !arg.starts_with("--") && !arch_values.contains(&arg.as_str()) {
            print_error(&format!("unexpected argument '{}'", arg));
            print_usage();
            std::process::exit(1);
        }
    }

    // Default to VST3 if no format specified
    let (build_vst3, build_auv2, build_auv3) = if !build_vst3 && !build_auv2 && !build_auv3 {
        (true, false, false)
    } else {
        (build_vst3, build_auv2, build_auv3)
    };

    let config = BundleConfig {
        package: package.to_string(),
        release,
        install,
        clean,
        verbose,
        build_vst3,
        build_auv2,
        build_auv3,
        arch,
    };

    if let Err(e) = bundle(&config) {
        print_error(&e);
        std::process::exit(1);
    }
}

fn print_usage() {
    eprintln!("Usage: cargo xtask bundle <package> [--vst3] [--auv2] [--auv3] [--arch <arch>] [--release] [--install] [--clean] [--verbose]");
    eprintln!();
    eprintln!("Commands:");
    eprintln!("  bundle    Build and bundle a plugin");
    eprintln!();
    eprintln!("Formats:");
    eprintln!("  --vst3    Build VST3 bundle (default if no format specified)");
    eprintln!("  --auv2    Build AUv2 .component bundle (simple distribution, works with all DAWs)");
    eprintln!("  --auv3    Build AUv3 .app/.appex bundle (App Store distribution)");
    eprintln!();
    eprintln!("Architecture:");
    eprintln!("  --arch <arch>  Target architecture (default: native)");
    eprintln!("                 native    - Current machine's architecture only (fastest builds)");
    eprintln!("                 universal - x86_64 + arm64 (for distribution)");
    eprintln!("                 arm64     - Apple Silicon only");
    eprintln!("                 x86_64    - Intel only");
    eprintln!();
    eprintln!("Options:");
    eprintln!("  --release    Build in release mode");
    eprintln!("  --install    Install to system plugin directories");
    eprintln!("               AUv2: ~/Library/Audio/Plug-Ins/Components/");
    eprintln!("               AUv3: ~/Applications/");
    eprintln!("  --clean      Clean build caches before building (forces full rebuild)");
    eprintln!("               Removes beamer-au cc cache and previous bundles.");
    eprintln!("               Use when ObjC/header changes aren't being picked up.");
    eprintln!("  --verbose    Show detailed build output (default: quiet)");
    eprintln!();
    eprintln!("Examples:");
    eprintln!("  cargo xtask bundle gain --vst3 --release --install");
    eprintln!("  cargo xtask bundle gain --auv2 --release --install");
    eprintln!("  cargo xtask bundle gain --auv3 --release --install");
    eprintln!("  cargo xtask bundle gain --auv2 --auv3 --arch universal    # Both AU formats");
    eprintln!("  cargo xtask bundle gain --vst3 --auv2 --arch universal    # VST3 + AUv2");
}

/// Find beamer-au output directory for a given target and profile.
/// Returns None if not found (beamer-au not yet built).
fn find_beamer_au_out_dir(workspace_root: &Path, target: &str, profile: &str) -> Option<PathBuf> {
    let build_dir = workspace_root
        .join("target")
        .join(target)
        .join(profile)
        .join("build");

    if !build_dir.exists() {
        return None;
    }

    // Find beamer-au-* directory
    for entry in fs::read_dir(&build_dir).ok()? {
        let entry = entry.ok()?;
        let name = entry.file_name();
        if name.to_string_lossy().starts_with("beamer-au-") {
            let out_dir = entry.path().join("out");
            if out_dir.exists() {
                return Some(out_dir);
            }
        }
    }

    None
}

/// Generate RUSTFLAGS for linking AU static libraries.
///
/// The `objc_lib_dir` parameter points to where plugin-specific ObjC static libraries
/// were compiled (contains libplugin_au_objc.a and libplugin_au_extension.a).
fn get_au_rustflags(
    plugin_name: &str,
    objc_lib_dir: &Path,
) -> Result<String, String> {
    let objc_lib_dir_str = objc_lib_dir.to_str()
        .ok_or_else(|| "Invalid ObjC library directory path".to_string())?;

    // Generate plugin-specific class and function names
    let pascal_name = to_pascal_case(plugin_name);
    let wrapper_class = format!("Beamer{}AuWrapper", pascal_name);
    let extension_class = format!("Beamer{}AuExtension", pascal_name);
    let factory_func = format!("Beamer{}AuExtensionFactory", pascal_name);

    // Library names based on plugin
    let lib_name = plugin_name.replace('-', "_");

    // Build RUSTFLAGS with all necessary linker arguments
    // Note: beamer_au_appex_force_link is internal (not exported) to avoid symbol collisions
    let flags = [
        format!("-L native={}", objc_lib_dir_str),
        format!("-C link-arg=-Wl,-force_load,{}/lib{}_au_objc.a", objc_lib_dir_str, lib_name),
        format!("-C link-arg=-Wl,-force_load,{}/lib{}_au_extension.a", objc_lib_dir_str, lib_name),
        format!("-C link-arg=-Wl,-exported_symbol,_OBJC_CLASS_$_{}", wrapper_class),
        format!("-C link-arg=-Wl,-exported_symbol,_OBJC_CLASS_$_{}", extension_class),
        format!("-C link-arg=-Wl,-exported_symbol,_OBJC_METACLASS_$_{}", wrapper_class),
        format!("-C link-arg=-Wl,-exported_symbol,_OBJC_METACLASS_$_{}", extension_class),
        format!("-C link-arg=-Wl,-exported_symbol,_{}", factory_func),
    ];

    Ok(flags.join(" "))
}

/// Build beamer-au to ensure static libraries exist before building plugins.
fn ensure_beamer_au_built(workspace_root: &Path, target: &str, release: bool) -> Result<(), String> {
    let profile = if release { "release" } else { "debug" };

    // Check if already built
    if find_beamer_au_out_dir(workspace_root, target, profile).is_some() {
        return Ok(());
    }

    println!("Building beamer-au for {}...", target);
    let mut cmd = Command::new("cargo");
    cmd.arg("build")
        .arg("-p")
        .arg("beamer-au")
        .arg("--target")
        .arg(target)
        .current_dir(workspace_root);

    if release {
        cmd.arg("--release");
    }

    let status = cmd.status()
        .map_err(|e| format!("Failed to build beamer-au: {}", e))?;

    if !status.success() {
        return Err("Failed to build beamer-au".to_string());
    }

    Ok(())
}

/// Build for a single architecture (native, arm64, or x86_64).
fn build_native(
    package: &str,
    release: bool,
    workspace_root: &Path,
    format: &str,
    arch: Arch,
    verbose: bool,
) -> Result<PathBuf, String> {
    // Always use explicit target to prevent RUSTFLAGS leaking into build scripts
    let target = match arch {
        Arch::Native => current_target(),
        Arch::Arm64 => "aarch64-apple-darwin",
        Arch::X86_64 => "x86_64-apple-darwin",
        Arch::Universal => unreachable!("Universal should use build_universal"),
    };

    let arch_name = if target.starts_with("aarch64") { "arm64" } else { "x86_64" };
    status!("  Building {} ({})...", format.to_uppercase(), arch_name);

    let profile = if release { "release" } else { "debug" };
    let lib_name = package.replace('-', "_");
    let dylib_name = format!("lib{}.dylib", lib_name);

    // AU requires additional setup (beamer-au and ObjC code)
    let rustflags = if format == "au" {
        ensure_beamer_au_built(workspace_root, target, release)?;
        verbose!(verbose, "    Generating plugin-specific ObjC for {}...", package);
        let objc_lib_dir = compile_plugin_objc(package, workspace_root, target)?;
        Some(get_au_rustflags(package, &objc_lib_dir)?)
    } else {
        None
    };

    let mut cmd = Command::new("cargo");
    cmd.arg("build")
        .arg("-p")
        .arg(package)
        .arg("--target")
        .arg(target)
        .arg("--features")
        .arg(format)
        .current_dir(workspace_root);

    if release {
        cmd.arg("--release");
    }

    if let Some(flags) = &rustflags {
        cmd.env("RUSTFLAGS", flags);
    }

    let status = cmd.status().map_err(|e| format!("Failed to run cargo: {}", e))?;
    if !status.success() {
        return Err(format!("{} build failed", format.to_uppercase()));
    }

    // Output is always in target/<target>/<profile>/
    let dylib_path = workspace_root.join("target").join(target).join(profile).join(&dylib_name);

    if !dylib_path.exists() {
        return Err(format!("Built library not found: {}", dylib_path.display()));
    }

    verbose!(verbose, "    Binary: {}", dylib_path.display());
    Ok(dylib_path)
}

/// Get the current host target triple.
fn current_target() -> &'static str {
    #[cfg(all(target_os = "macos", target_arch = "aarch64"))]
    return "aarch64-apple-darwin";

    #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
    return "x86_64-apple-darwin";

    #[cfg(not(target_os = "macos"))]
    compile_error!("Unsupported platform");
}

/// Build universal binary (x86_64 + arm64) for the given format.
fn build_universal(
    package: &str,
    release: bool,
    workspace_root: &Path,
    format: &str,
    verbose: bool,
) -> Result<PathBuf, String> {
    status!("  Building {} (universal)...", format.to_uppercase());

    let profile = if release { "release" } else { "debug" };
    let lib_name = package.replace('-', "_");
    let dylib_name = format!("lib{}.dylib", lib_name);

    // AU requires additional setup (beamer-au and ObjC code)
    let (rustflags_x86, rustflags_arm) = if format == "au" {
        ensure_beamer_au_built(workspace_root, "x86_64-apple-darwin", release)?;
        ensure_beamer_au_built(workspace_root, "aarch64-apple-darwin", release)?;

        verbose!(verbose, "    Generating plugin-specific ObjC for {}...", package);
        let objc_lib_dir_x86 = compile_plugin_objc(package, workspace_root, "x86_64-apple-darwin")?;
        let objc_lib_dir_arm = compile_plugin_objc(package, workspace_root, "aarch64-apple-darwin")?;

        (
            Some(get_au_rustflags(package, &objc_lib_dir_x86)?),
            Some(get_au_rustflags(package, &objc_lib_dir_arm)?),
        )
    } else {
        (None, None)
    };

    // Build for x86_64
    verbose!(verbose, "    Building for x86_64...");
    let mut cmd = Command::new("cargo");
    cmd.arg("build")
        .arg("-p")
        .arg(package)
        .arg("--target")
        .arg("x86_64-apple-darwin")
        .arg("--features")
        .arg(format)
        .current_dir(workspace_root);

    if release {
        cmd.arg("--release");
    }

    if let Some(flags) = &rustflags_x86 {
        cmd.env("RUSTFLAGS", flags);
    }

    let status = cmd.status().map_err(|e| format!("Failed to build for x86_64: {}", e))?;
    if !status.success() {
        return Err("Build for x86_64 failed".to_string());
    }

    // Build for arm64
    verbose!(verbose, "    Building for arm64...");
    let mut cmd = Command::new("cargo");
    cmd.arg("build")
        .arg("-p")
        .arg(package)
        .arg("--target")
        .arg("aarch64-apple-darwin")
        .arg("--features")
        .arg(format)
        .current_dir(workspace_root);

    if release {
        cmd.arg("--release");
    }

    if let Some(flags) = &rustflags_arm {
        cmd.env("RUSTFLAGS", flags);
    }

    let status = cmd.status().map_err(|e| format!("Failed to build for arm64: {}", e))?;
    if !status.success() {
        return Err("Build for arm64 failed".to_string());
    }

    // Paths to the built binaries
    let x86_64_path = workspace_root
        .join("target")
        .join("x86_64-apple-darwin")
        .join(profile)
        .join(&dylib_name);

    let arm64_path = workspace_root
        .join("target")
        .join("aarch64-apple-darwin")
        .join(profile)
        .join(&dylib_name);

    // Output path for universal binary
    let universal_path = workspace_root
        .join("target")
        .join(profile)
        .join(&dylib_name);

    // Create target directory if it doesn't exist
    if let Some(parent) = universal_path.parent() {
        fs::create_dir_all(parent).map_err(|e| format!("Failed to create target dir: {}", e))?;
    }

    // Combine using lipo
    verbose!(verbose, "    Creating universal binary with lipo...");
    let status = Command::new("lipo")
        .args([
            "-create",
            x86_64_path.to_str().unwrap(),
            arm64_path.to_str().unwrap(),
            "-output",
            universal_path.to_str().unwrap(),
        ])
        .status()
        .map_err(|e| format!("Failed to run lipo: {}", e))?;

    if !status.success() {
        return Err("lipo failed to create universal binary".to_string());
    }

    verbose!(verbose, "    Binary: {}", universal_path.display());

    Ok(universal_path)
}

/// Clean build caches to force full rebuild.
///
/// This is necessary because:
/// 1. `cc::Build` (used in build.rs) caches compiled .o files in target/build/beamer-au-*/
/// 2. Even if cargo triggers a rebuild, cc may use cached object files
/// 3. The final .app bundle may not get updated if only static libraries changed
///
/// Use --clean when ObjC or header file changes aren't being picked up.
fn clean_build_caches(
    workspace_root: &Path,
    package: &str,
    release: bool,
    verbose: bool,
    build_auv2: bool,
    build_auv3: bool,
    build_vst3: bool,
) -> Result<(), String> {
    let profile = if release { "release" } else { "debug" };
    let target_dir = workspace_root.join("target").join(profile);
    let clean_au = build_auv2 || build_auv3;

    // Build description of what we're cleaning
    let mut targets = Vec::new();
    if clean_au {
        targets.push("AU caches");
    }
    if build_auv2 {
        targets.push("AUv2");
    }
    if build_auv3 {
        targets.push("AUv3");
    }
    if build_vst3 {
        targets.push("VST3");
    }
    status!("  Cleaning ({})...", targets.join(", "));

    // Clean beamer-au cc cache (compiled ObjC objects) - only for AU builds
    if clean_au {
        let build_dir = workspace_root.join("target").join(profile).join("build");
        if build_dir.exists() {
            for entry in fs::read_dir(&build_dir).map_err(|e| e.to_string())? {
                let entry = entry.map_err(|e| e.to_string())?;
                let name = entry.file_name();
                if name.to_string_lossy().starts_with("beamer-au-") {
                    verbose!(verbose, "    Removing: {}", entry.path().display());
                    fs::remove_dir_all(entry.path()).map_err(|e| e.to_string())?;
                }
            }
        }

        // Clean beamer-au deps (compiled Rust library)
        let deps_dir = target_dir.join("deps");
        if deps_dir.exists() {
            for entry in fs::read_dir(&deps_dir).map_err(|e| e.to_string())? {
                let entry = entry.map_err(|e| e.to_string())?;
                let name = entry.file_name();
                let name_str = name.to_string_lossy();
                if name_str.starts_with("libbeamer_au") {
                    verbose!(verbose, "    Removing: {}", entry.path().display());
                    fs::remove_file(entry.path()).map_err(|e| e.to_string())?;
                }
            }
        }
    }

    // Clean previous VST3 bundle
    if build_vst3 {
        let vst3_bundle_name = to_vst3_bundle_name(package);
        let vst3_path = target_dir.join(&vst3_bundle_name);
        if vst3_path.exists() {
            verbose!(verbose, "    Removing: {}", vst3_path.display());
            fs::remove_dir_all(&vst3_path).map_err(|e| e.to_string())?;
        }
    }

    // Clean previous AUv2 component bundle
    if build_auv2 {
        let auv2_bundle_name = to_auv2_component_name(package);
        let component_path = target_dir.join(&auv2_bundle_name);
        if component_path.exists() {
            verbose!(verbose, "    Removing: {}", component_path.display());
            fs::remove_dir_all(&component_path).map_err(|e| e.to_string())?;
        }
    }

    // Clean previous AUv3 app bundle
    if build_auv3 {
        let auv3_bundle_name = to_au_bundle_name(package);
        let app_path = target_dir.join(&auv3_bundle_name);
        if app_path.exists() {
            verbose!(verbose, "    Removing: {}", app_path.display());
            fs::remove_dir_all(&app_path).map_err(|e| e.to_string())?;
        }
    }

    Ok(())
}

fn bundle(config: &BundleConfig) -> Result<(), String> {
    let arch_str = match config.arch {
        Arch::Native => "native",
        Arch::Universal => "universal",
        Arch::Arm64 => "arm64",
        Arch::X86_64 => "x86_64",
    };
    let profile_str = if config.release { "release" } else { "debug" };
    status!("Bundling {} ({}, {})...", config.package, profile_str, arch_str);

    // Get workspace root
    let workspace_root = get_workspace_root()?;

    // Clean build caches if requested
    if config.clean {
        clean_build_caches(
            &workspace_root,
            &config.package,
            config.release,
            config.verbose,
            config.build_auv2,
            config.build_auv3,
            config.build_vst3,
        )?;
    }

    // Determine paths
    let target_dir = workspace_root.join("target").join(profile_str);

    // Build and bundle AU (macOS only) - build once, bundle for each requested format
    if (config.build_auv2 || config.build_auv3) && cfg!(target_os = "macos") {
        let dylib_path = if config.arch == Arch::Universal {
            build_universal(&config.package, config.release, &workspace_root, "au", config.verbose)?
        } else {
            build_native(&config.package, config.release, &workspace_root, "au", config.arch, config.verbose)?
        };

        if config.build_auv2 {
            bundle_auv2(&config.package, &target_dir, &dylib_path, config.install, &workspace_root, config.arch, config.verbose)?;
        }
        if config.build_auv3 {
            bundle_auv3(&config.package, &target_dir, &dylib_path, config.install, &workspace_root, config.arch, config.verbose)?;
        }
    }

    // Build and bundle VST3
    if config.build_vst3 {
        let dylib_path = if config.arch == Arch::Universal {
            build_universal(&config.package, config.release, &workspace_root, "vst3", config.verbose)?
        } else {
            build_native(&config.package, config.release, &workspace_root, "vst3", config.arch, config.verbose)?
        };
        bundle_vst3(&config.package, &target_dir, &dylib_path, config.install, config.verbose)?;
    }

    Ok(())
}

fn bundle_vst3(
    package: &str,
    target_dir: &Path,
    dylib_path: &Path,
    install: bool,
    verbose: bool,
) -> Result<(), String> {
    // Create bundle name (convert to CamelCase and add .vst3)
    let bundle_name = to_vst3_bundle_name(package);
    let bundle_dir = target_dir.join(&bundle_name);

    // Create bundle directory structure
    let contents_dir = bundle_dir.join("Contents");
    let macos_dir = contents_dir.join("MacOS");
    let resources_dir = contents_dir.join("Resources");

    status!("  Creating VST3 bundle...");
    verbose!(verbose, "    Path: {}", bundle_dir.display());

    // Clean up existing bundle
    if bundle_dir.exists() {
        fs::remove_dir_all(&bundle_dir).map_err(|e| format!("Failed to remove old bundle: {}", e))?;
    }

    // Create directories
    fs::create_dir_all(&macos_dir).map_err(|e| format!("Failed to create MacOS dir: {}", e))?;
    fs::create_dir_all(&resources_dir)
        .map_err(|e| format!("Failed to create Resources dir: {}", e))?;

    // Copy dylib
    let plugin_binary = macos_dir.join(bundle_name.trim_end_matches(".vst3"));
    fs::copy(dylib_path, &plugin_binary)
        .map_err(|e| format!("Failed to copy dylib: {}", e))?;

    // Create Info.plist
    let info_plist = create_vst3_info_plist(package, &bundle_name);
    fs::write(contents_dir.join("Info.plist"), info_plist)
        .map_err(|e| format!("Failed to write Info.plist: {}", e))?;

    // Create PkgInfo
    fs::write(contents_dir.join("PkgInfo"), "BNDL????")
        .map_err(|e| format!("Failed to write PkgInfo: {}", e))?;

    // Install if requested
    if install {
        install_vst3(&bundle_dir, &bundle_name, verbose)?;
    } else {
        status!("âœ“ {}", bundle_name);
    }

    Ok(())
}

fn bundle_auv2(
    package: &str,
    target_dir: &Path,
    dylib_path: &Path,
    install: bool,
    workspace_root: &Path,
    arch: Arch,
    verbose: bool,
) -> Result<(), String> {
    // Create AUv2 .component bundle structure:
    // BeamerGain.component/
    // â”œâ”€â”€ Contents/
    // â”‚   â”œâ”€â”€ Info.plist       â† AudioComponents + factoryFunction
    // â”‚   â”œâ”€â”€ MacOS/
    // â”‚   â”‚   â””â”€â”€ BeamerGain   â† Plugin dylib with factory symbol
    // â”‚   â”œâ”€â”€ Resources/
    // â”‚   â””â”€â”€ PkgInfo

    // Get version from Cargo.toml
    let (version_string, version_int) = get_version_info(workspace_root)?;

    let bundle_name = to_auv2_component_name(package);
    let bundle_dir = target_dir.join(&bundle_name);
    let contents_dir = bundle_dir.join("Contents");
    let macos_dir = contents_dir.join("MacOS");
    let resources_dir = contents_dir.join("Resources");

    status!("  Creating AUv2 component...");
    verbose!(verbose, "    Path: {}", bundle_dir.display());

    // Clean up existing bundle
    if bundle_dir.exists() {
        fs::remove_dir_all(&bundle_dir).map_err(|e| format!("Failed to remove old bundle: {}", e))?;
    }

    // Create directories
    fs::create_dir_all(&macos_dir).map_err(|e| format!("Failed to create MacOS dir: {}", e))?;
    fs::create_dir_all(&resources_dir).map_err(|e| format!("Failed to create Resources dir: {}", e))?;

    // Auto-detect component type, manufacturer, and subtype from plugin source
    let (component_type, detected_manufacturer, detected_subtype, detected_plugin_name, detected_vendor_name) =
        detect_au_component_info(package, workspace_root);
    verbose!(
        verbose,
        "    Detected: {} (manufacturer: {}, subtype: {})",
        component_type,
        detected_manufacturer.as_deref().unwrap_or("Bemr"),
        detected_subtype.as_deref().unwrap_or("auto")
    );
    if let Some(ref name) = detected_plugin_name {
        verbose!(verbose, "    Plugin name: {}", name);
    }
    if let Some(ref vendor) = detected_vendor_name {
        verbose!(verbose, "    Vendor: {}", vendor);
    }

    // Generate ObjC wrapper with factory function
    let wrapper_source = generate_auv2_wrapper_source(package);
    let gen_dir = workspace_root.join("target/au-gen").join(package);
    fs::create_dir_all(&gen_dir).map_err(|e| format!("Failed to create gen dir: {}", e))?;
    let wrapper_path = gen_dir.join("auv2_wrapper.m");
    fs::write(&wrapper_path, wrapper_source).map_err(|e| format!("Failed to write wrapper: {}", e))?;

    // Build for each architecture
    let arches = match arch {
        Arch::Universal => vec!["x86_64", "arm64"],
        Arch::Native => vec![if cfg!(target_arch = "aarch64") { "arm64" } else { "x86_64" }],
        Arch::Arm64 => vec!["arm64"],
        Arch::X86_64 => vec!["x86_64"],
    };

    let arch_str = if arches.len() > 1 { "universal" } else { arches[0] };
    verbose!(verbose, "    Building component ({})...", arch_str);

    // Get bridge header path
    let bridge_header_dir = workspace_root.join("crates/beamer-au/objc");

    let executable_name = bundle_name.trim_end_matches(".component");
    let binary_dest = macos_dir.join(executable_name);

    let mut built_paths: Vec<PathBuf> = Vec::new();

    for target_arch in &arches {
        let arch_output = gen_dir.join(format!("{}_{}", executable_name, target_arch));

        // Compile ObjC wrapper and link with Rust dylib as a bundle
        let clang_status = Command::new("clang")
            .args([
                "-arch", target_arch,
                "-bundle",  // Create a bundle (loadable module), not an executable
                "-fobjc-arc",
                "-fmodules",
                "-framework", "Foundation",
                "-framework", "AudioToolbox",
                "-framework", "AVFoundation",
                "-framework", "CoreAudio",
                "-framework", "CoreAudioKit",
                "-I", bridge_header_dir.to_str().unwrap(),
                dylib_path.to_str().unwrap(),  // Link directly with the dylib
                "-Wl,-rpath,@loader_path",
                "-o", arch_output.to_str().unwrap(),
                wrapper_path.to_str().unwrap(),
            ])
            .status()
            .map_err(|e| format!("Failed to run clang for {}: {}", target_arch, e))?;

        if !clang_status.success() {
            return Err(format!("Failed to build AUv2 component for {}", target_arch));
        }
        built_paths.push(arch_output);
    }

    if built_paths.len() == 1 {
        // Single architecture - just rename
        fs::rename(&built_paths[0], &binary_dest)
            .map_err(|e| format!("Failed to rename binary: {}", e))?;
    } else {
        // Multiple architectures - combine with lipo
        let mut lipo_args: Vec<&str> = vec!["-create"];
        for path in &built_paths {
            lipo_args.push(path.to_str().unwrap());
        }
        lipo_args.push("-output");
        lipo_args.push(binary_dest.to_str().unwrap());

        let lipo_status = Command::new("lipo")
            .args(&lipo_args)
            .status()
            .map_err(|e| format!("Failed to run lipo: {}", e))?;

        if !lipo_status.success() {
            return Err("Failed to create universal binary".to_string());
        }

        // Clean up intermediate binaries
        for path in &built_paths {
            let _ = fs::remove_file(path);
        }
    }

    // Copy dylib next to the binary (for @rpath resolution)
    let dylib_name = dylib_path.file_name().unwrap();
    let dylib_dest = macos_dir.join(dylib_name);
    fs::copy(dylib_path, &dylib_dest).map_err(|e| format!("Failed to copy dylib: {}", e))?;

    // Create Info.plist with factoryFunction
    let info_plist = create_component_info_plist(&ComponentPlistConfig {
        package,
        executable_name,
        component_type: &component_type,
        manufacturer: detected_manufacturer.as_deref(),
        subtype: detected_subtype.as_deref(),
        version_string: &version_string,
        version_int,
        plugin_name: detected_plugin_name.as_deref(),
        vendor_name: detected_vendor_name.as_deref(),
    });
    fs::write(contents_dir.join("Info.plist"), info_plist)
        .map_err(|e| format!("Failed to write Info.plist: {}", e))?;

    // Create PkgInfo
    fs::write(contents_dir.join("PkgInfo"), "BNDL????")
        .map_err(|e| format!("Failed to write PkgInfo: {}", e))?;

    // Code sign with ad-hoc signature
    verbose!(verbose, "    Signing...");
    let sign_result = Command::new("codesign")
        .args(["--force", "--sign", "-", bundle_dir.to_str().unwrap()])
        .output();

    match sign_result {
        Ok(output) if output.status.success() => {
            if verbose {
                let stderr = String::from_utf8_lossy(&output.stderr);
                if !stderr.is_empty() {
                    for line in stderr.lines() {
                        verbose!(verbose, "    {}", line);
                    }
                }
                verbose!(verbose, "    Code signing successful");
            }
        }
        Ok(_) => status!("  Warning: Code signing failed"),
        Err(e) => status!("  Warning: Could not run codesign: {}", e),
    }

    // Install if requested
    if install {
        install_auv2(&bundle_dir, &bundle_name, verbose)?;
    } else {
        status!("âœ“ {}", bundle_name);
    }

    Ok(())
}

fn bundle_auv3(
    package: &str,
    target_dir: &Path,
    dylib_path: &Path,
    install: bool,
    workspace_root: &Path,
    arch: Arch,
    verbose: bool,
) -> Result<(), String> {
    // Create AUv3 .app bundle structure with .appex extension:
    // BeamerGain.app/                         # Container app
    // â”œâ”€â”€ Contents/
    // â”‚   â”œâ”€â”€ Info.plist                      # Minimal app plist (LSUIElement=true)
    // â”‚   â”œâ”€â”€ MacOS/
    // â”‚   â”‚   â””â”€â”€ BeamerGain                  # Symlink to appex binary
    // â”‚   â”œâ”€â”€ PlugIns/
    // â”‚   â”‚   â””â”€â”€ BeamerGain.appex/           # The actual AU extension
    // â”‚   â”‚       â”œâ”€â”€ Contents/
    // â”‚   â”‚       â”‚   â”œâ”€â”€ Info.plist          # NSExtension + AudioComponents
    // â”‚   â”‚       â”‚   â”œâ”€â”€ MacOS/
    // â”‚   â”‚       â”‚   â”‚   â””â”€â”€ BeamerGain      # Plugin dylib
    // â”‚   â”‚       â”‚   â””â”€â”€ Resources/
    // â”‚   â”œâ”€â”€ Resources/
    // â”‚   â””â”€â”€ PkgInfo                         # "APPL????"

    // Get version from Cargo.toml
    let (version_string, version_int) = get_version_info(workspace_root)?;

    let bundle_name = to_au_bundle_name(package);
    let bundle_dir = target_dir.join(&bundle_name);
    let contents_dir = bundle_dir.join("Contents");
    let app_resources_dir = contents_dir.join("Resources");
    let plugins_dir = contents_dir.join("PlugIns");

    status!("  Creating AUv3 app extension...");
    verbose!(verbose, "    Path: {}", bundle_dir.display());

    // Clean up existing bundle
    if bundle_dir.exists() {
        fs::remove_dir_all(&bundle_dir).map_err(|e| format!("Failed to remove old bundle: {}", e))?;
    }

    // Create app directories
    let app_macos_dir = contents_dir.join("MacOS");
    let frameworks_dir = contents_dir.join("Frameworks");
    fs::create_dir_all(&app_macos_dir).map_err(|e| format!("Failed to create app MacOS dir: {}", e))?;
    fs::create_dir_all(&app_resources_dir).map_err(|e| format!("Failed to create app Resources dir: {}", e))?;
    fs::create_dir_all(&plugins_dir).map_err(|e| format!("Failed to create PlugIns dir: {}", e))?;
    fs::create_dir_all(&frameworks_dir).map_err(|e| format!("Failed to create Frameworks dir: {}", e))?;

    // Create the .appex bundle structure
    let executable_name = bundle_name.trim_end_matches(".app");
    let appex_name = format!("{}.appex", executable_name);
    let appex_dir = plugins_dir.join(&appex_name);
    let appex_contents_dir = appex_dir.join("Contents");
    let appex_macos_dir = appex_contents_dir.join("MacOS");
    let appex_resources_dir = appex_contents_dir.join("Resources");

    fs::create_dir_all(&appex_macos_dir).map_err(|e| format!("Failed to create appex MacOS dir: {}", e))?;
    fs::create_dir_all(&appex_resources_dir).map_err(|e| format!("Failed to create appex Resources dir: {}", e))?;

    // Create framework bundle for in-process AU loading on macOS.
    // Use versioned framework structure (standard macOS framework layout):
    // Framework.framework/
    // â”œâ”€â”€ Framework -> Versions/Current/Framework  (symlink)
    // â”œâ”€â”€ Resources -> Versions/Current/Resources  (symlink)
    // â””â”€â”€ Versions/
    //     â”œâ”€â”€ A/
    //     â”‚   â”œâ”€â”€ Framework (binary)
    //     â”‚   â”œâ”€â”€ Resources/
    //     â”‚   â”‚   â””â”€â”€ Info.plist
    //     â”‚   â””â”€â”€ _CodeSignature/
    //     â””â”€â”€ Current -> A  (symlink)
    let framework_name = format!("{}AU", executable_name);
    let framework_bundle_id = format!("com.beamer.{}.framework", package);
    let framework_dir = frameworks_dir.join(format!("{}.framework", framework_name));

    // Create versioned directory structure
    let versions_dir = framework_dir.join("Versions");
    let version_a_dir = versions_dir.join("A");
    let version_a_resources = version_a_dir.join("Resources");
    fs::create_dir_all(&version_a_resources)
        .map_err(|e| format!("Failed to create framework Versions/A/Resources dir: {}", e))?;

    // Copy dylib to Versions/A/
    let framework_binary = version_a_dir.join(&framework_name);
    fs::copy(dylib_path, &framework_binary)
        .map_err(|e| format!("Failed to copy dylib to framework: {}", e))?;

    // Fix dylib install name to use @rpath with versioned path
    let _ = Command::new("install_name_tool")
        .args(["-id", &format!("@rpath/{}.framework/Versions/A/{}", framework_name, framework_name),
               framework_binary.to_str().unwrap()])
        .status();

    // Create framework Info.plist in Versions/A/Resources/
    let framework_plist = format!(r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>{framework_name}</string>
    <key>CFBundleIdentifier</key>
    <string>{bundle_id}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{framework_name}</string>
    <key>CFBundlePackageType</key>
    <string>FMWK</string>
    <key>CFBundleVersion</key>
    <string>{version}</string>
    <key>CFBundleShortVersionString</key>
    <string>{version}</string>
</dict>
</plist>
"#, framework_name = framework_name, bundle_id = framework_bundle_id, version = version_string);
    fs::write(version_a_resources.join("Info.plist"), framework_plist)
        .map_err(|e| format!("Failed to write framework Info.plist: {}", e))?;

    // Create symlinks for versioned framework structure
    // Versions/Current -> A
    #[cfg(unix)]
    {
        use std::os::unix::fs::symlink;
        let current_link = versions_dir.join("Current");
        let _ = fs::remove_file(&current_link); // Remove if exists
        symlink("A", &current_link)
            .map_err(|e| format!("Failed to create Versions/Current symlink: {}", e))?;

        // Framework root symlinks
        // Framework -> Versions/Current/Framework
        let binary_link = framework_dir.join(&framework_name);
        let _ = fs::remove_file(&binary_link);
        symlink(format!("Versions/Current/{}", framework_name), &binary_link)
            .map_err(|e| format!("Failed to create framework binary symlink: {}", e))?;

        // Resources -> Versions/Current/Resources
        let resources_link = framework_dir.join("Resources");
        let _ = fs::remove_file(&resources_link);
        symlink("Versions/Current/Resources", &resources_link)
            .map_err(|e| format!("Failed to create Resources symlink: {}", e))?;
    }

    verbose!(verbose, "    Created framework: {}.framework", framework_name);

    // Build appex executable - thin wrapper that links the framework
    let appex_binary_path = appex_macos_dir.join(executable_name);

    // Generate plugin-specific appex_stub.m (no main function - uses NSExtensionMain)
    let appex_stub_source = generate_appex_stub_source(package);
    let appex_gen_dir = workspace_root.join("target/au-gen").join(package);
    fs::create_dir_all(&appex_gen_dir)
        .map_err(|e| format!("Failed to create appex gen dir: {}", e))?;
    let appex_stub_path = appex_gen_dir.join("appex_stub.m");
    fs::write(&appex_stub_path, appex_stub_source)
        .map_err(|e| format!("Failed to write appex_stub.m: {}", e))?;

    // Build appex executable with appropriate architecture(s)
    let arches = match arch {
        Arch::Universal => vec!["x86_64", "arm64"],
        Arch::Native => vec![if cfg!(target_arch = "aarch64") { "arm64" } else { "x86_64" }],
        Arch::Arm64 => vec!["arm64"],
        Arch::X86_64 => vec!["x86_64"],
    };

    let arch_str = if arches.len() > 1 { "universal" } else { arches[0] };
    verbose!(verbose, "    Building appex executable ({})...", arch_str);

    let mut built_paths: Vec<PathBuf> = Vec::new();

    for target_arch in &arches {
        let appex_arch_path = bundle_dir.join(format!("{}_{}", executable_name, target_arch));
        let clang_status = Command::new("clang")
            .args([
                "-arch", target_arch,
                "-fobjc-arc",
                "-fmodules",
                "-framework", "Foundation",
                "-framework", "AudioToolbox",
                "-framework", "AVFoundation",
                "-framework", "CoreAudio",
                "-F", frameworks_dir.to_str().unwrap(),
                "-framework", &framework_name,
                "-Wl,-rpath,@loader_path/../../../../Frameworks",
                "-Wl,-e,_NSExtensionMain",  // Use Apple's standard extension entry point
                "-o", appex_arch_path.to_str().unwrap(),
                appex_stub_path.to_str().unwrap(),
            ])
            .status()
            .map_err(|e| format!("Failed to run clang for {}: {}", target_arch, e))?;

        if !clang_status.success() {
            return Err(format!("Failed to build appex for {}", target_arch));
        }
        built_paths.push(appex_arch_path);
    }

    if built_paths.len() == 1 {
        // Single architecture - just rename
        fs::rename(&built_paths[0], &appex_binary_path)
            .map_err(|e| format!("Failed to rename appex binary: {}", e))?;
    } else {
        // Multiple architectures - combine with lipo
        let mut lipo_args: Vec<&str> = vec!["-create"];
        for path in &built_paths {
            lipo_args.push(path.to_str().unwrap());
        }
        lipo_args.push("-output");
        lipo_args.push(appex_binary_path.to_str().unwrap());

        let lipo_status = Command::new("lipo")
            .args(&lipo_args)
            .status()
            .map_err(|e| format!("Failed to run lipo for appex: {}", e))?;

        if !lipo_status.success() {
            return Err("Failed to create universal appex binary".to_string());
        }

        // Clean up intermediate binaries
        for path in &built_paths {
            let _ = fs::remove_file(path);
        }
    }

    verbose!(verbose, "    Appex executable built ({})", arch_str);

    // Auto-detect component type, manufacturer, and subtype from plugin source
    let (component_type, detected_manufacturer, detected_subtype, detected_plugin_name, detected_vendor_name) = detect_au_component_info(package, workspace_root);
    verbose!(
        verbose,
        "    Detected: {} (manufacturer: {}, subtype: {})",
        component_type,
        detected_manufacturer.as_deref().unwrap_or("Bemr"),
        detected_subtype.as_deref().unwrap_or("auto")
    );
    if let Some(ref name) = detected_plugin_name {
        verbose!(verbose, "    Plugin name: {}", name);
    }
    if let Some(ref vendor) = detected_vendor_name {
        verbose!(verbose, "    Vendor: {}", vendor);
    }

    // Create appex Info.plist with NSExtension (out-of-process/XPC mode)
    let appex_info_plist = create_appex_info_plist(&AppexPlistConfig {
        package,
        executable_name,
        component_type: &component_type,
        manufacturer: detected_manufacturer.as_deref(),
        subtype: detected_subtype.as_deref(),
        framework_bundle_id: &framework_bundle_id,
        version_string: &version_string,
        version_int,
        plugin_name: detected_plugin_name.as_deref(),
        vendor_name: detected_vendor_name.as_deref(),
    });
    fs::write(appex_contents_dir.join("Info.plist"), appex_info_plist)
        .map_err(|e| format!("Failed to write appex Info.plist: {}", e))?;

    // Create container app Info.plist
    let app_info_plist = create_app_info_plist(package, executable_name, &version_string);
    fs::write(contents_dir.join("Info.plist"), app_info_plist)
        .map_err(|e| format!("Failed to write app Info.plist: {}", e))?;

    // Create PkgInfo for app
    fs::write(contents_dir.join("PkgInfo"), "APPL????")
        .map_err(|e| format!("Failed to write PkgInfo: {}", e))?;

    // Build host app executable from C stub.
    // This is a minimal stub that triggers pluginkit registration when launched.
    // The app is marked LSBackgroundOnly so it exits immediately after registration.
    verbose!(verbose, "    Building host app executable ({})...", arch_str);

    let stub_main_path = workspace_root.join("crates/beamer-au/objc/stub_main.c");
    let host_binary_dst = app_macos_dir.join(executable_name);

    let mut host_built_paths: Vec<PathBuf> = Vec::new();

    for target_arch in &arches {
        let host_arch_path = bundle_dir.join(format!("{}_{}", executable_name, target_arch));
        let clang_status = Command::new("clang")
            .args([
                "-arch", target_arch,
                "-framework", "Foundation",
                "-o", host_arch_path.to_str().unwrap(),
                stub_main_path.to_str().unwrap(),
            ])
            .status()
            .map_err(|e| format!("Failed to run clang for {}: {}", target_arch, e))?;

        if !clang_status.success() {
            return Err(format!("Failed to build host app for {}", target_arch));
        }
        host_built_paths.push(host_arch_path);
    }

    if host_built_paths.len() == 1 {
        // Single architecture - just rename
        fs::rename(&host_built_paths[0], &host_binary_dst)
            .map_err(|e| format!("Failed to rename host binary: {}", e))?;
    } else {
        // Multiple architectures - combine with lipo
        let mut lipo_args: Vec<&str> = vec!["-create"];
        for path in &host_built_paths {
            lipo_args.push(path.to_str().unwrap());
        }
        lipo_args.push("-output");
        lipo_args.push(host_binary_dst.to_str().unwrap());

        let lipo_status = Command::new("lipo")
            .args(&lipo_args)
            .status()
            .map_err(|e| format!("Failed to run lipo for host app: {}", e))?;

        if !lipo_status.success() {
            return Err("Failed to create universal host app binary".to_string());
        }

        // Clean up intermediate binaries
        for path in &host_built_paths {
            let _ = fs::remove_file(path);
        }
    }

    verbose!(verbose, "    Host app built ({})", arch_str);

    // Code sign framework first, then appex, then container app
    verbose!(verbose, "    Signing...");
    let framework_sign_result = Command::new("codesign")
        .args(["--force", "--sign", "-", framework_dir.to_str().unwrap()])
        .output();

    match framework_sign_result {
        Ok(output) if output.status.success() => {
            if verbose {
                let stderr = String::from_utf8_lossy(&output.stderr);
                for line in stderr.lines() {
                    verbose!(verbose, "    {}", line);
                }
            }
            verbose!(verbose, "    Framework code signing successful")
        }
        Ok(_) => status!("  Warning: Framework code signing failed"),
        Err(e) => status!("  Warning: Could not run codesign on framework: {}", e),
    }

    let entitlements_path = workspace_root.join("crates/beamer-au/resources/appex.entitlements");
    let appex_sign_result = Command::new("codesign")
        .args([
            "--force",
            "--sign", "-",
            "--entitlements", entitlements_path.to_str().unwrap(),
            appex_dir.to_str().unwrap()
        ])
        .output();

    match appex_sign_result {
        Ok(output) if output.status.success() => {
            if verbose {
                let stderr = String::from_utf8_lossy(&output.stderr);
                for line in stderr.lines() {
                    verbose!(verbose, "    {}", line);
                }
            }
            verbose!(verbose, "    Appex code signing successful")
        }
        Ok(_) => status!("  Warning: Appex code signing failed"),
        Err(e) => status!("  Warning: Could not run codesign on appex: {}", e),
    }

    let app_sign_result = Command::new("codesign")
        .args(["--force", "--sign", "-", bundle_dir.to_str().unwrap()])
        .output();

    match app_sign_result {
        Ok(output) if output.status.success() => {
            if verbose {
                let stderr = String::from_utf8_lossy(&output.stderr);
                for line in stderr.lines() {
                    verbose!(verbose, "    {}", line);
                }
            }
            verbose!(verbose, "    Container app code signing successful")
        }
        Ok(_) => status!("  Warning: Container app code signing failed"),
        Err(e) => status!("  Warning: Could not run codesign on app: {}", e),
    }

    // Install if requested
    if install {
        install_au(&bundle_dir, &bundle_name, verbose)?;
    } else {
        status!("âœ“ {}", bundle_name);
    }

    Ok(())
}

/// Detect AU component type, manufacturer, subtype, and plugin metadata from source code.
///
/// Parses the plugin's lib.rs file looking for:
/// - `AuConfig::new()` declaration to extract ComponentType and fourcc codes
/// - `PluginConfig::new()` to extract plugin name and vendor
///
/// Returns (component_type_code, manufacturer_option, subtype_option, plugin_name, vendor_name)
fn detect_au_component_info(package: &str, workspace_root: &Path) -> (String, Option<String>, Option<String>, Option<String>, Option<String>) {
    // Try to find the lib.rs for this package
    let lib_path = workspace_root.join("examples").join(package).join("src/lib.rs");

    if let Ok(content) = fs::read_to_string(&lib_path) {
        // Detect component type
        let component_type = if content.contains("ComponentType::MusicDevice")
            || content.contains("ComponentType::Generator")
        {
            "aumu".to_string()
        } else if content.contains("ComponentType::MidiProcessor") {
            "aumi".to_string()
        } else if content.contains("ComponentType::MusicEffect") {
            "aumf".to_string()
        } else {
            // Default to effect (aufx)
            "aufx".to_string()
        };

        // Detect manufacturer and subtype from fourcc!(b"xxxx") patterns
        // Pattern: AuConfig::new(type, fourcc!(b"manu"), fourcc!(b"subt"))
        let (manufacturer, subtype) = detect_au_fourcc_codes(&content);

        // Detect plugin name and vendor from PluginConfig
        let (plugin_name, vendor_name) = detect_plugin_metadata(&content);

        (component_type, manufacturer, subtype, plugin_name, vendor_name)
    } else {
        // Default to effect if we can't read the file
        ("aufx".to_string(), None, None, None, None)
    }
}

/// Extract AU fourcc codes (manufacturer and subtype) from plugin source code.
///
/// Looks for the pattern `fourcc!(b"xxxx")` which appears in
/// `AuConfig::new(ComponentType::..., fourcc!(b"manu"), fourcc!(b"subt"))`.
///
/// Returns (manufacturer, subtype) as Options.
fn detect_au_fourcc_codes(content: &str) -> (Option<String>, Option<String>) {
    // Find all fourcc!(b"xxxx") patterns
    let mut fourcc_codes: Vec<String> = Vec::new();

    let mut remaining = content;
    while let Some(start) = remaining.find("fourcc!(b\"") {
        let after_prefix = &remaining[start + 10..]; // Skip "fourcc!(b\""
        if let Some(end) = after_prefix.find('"') {
            let code = &after_prefix[..end];
            if code.len() == 4 && code.is_ascii() {
                fourcc_codes.push(code.to_string());
            }
        }
        // Move past this match to find next
        remaining = &remaining[start + 10..];
    }

    // In AuConfig::new(type, manufacturer, subtype):
    // - First fourcc! is manufacturer
    // - Second fourcc! is subtype
    let manufacturer = fourcc_codes.first().cloned();
    let subtype = fourcc_codes.get(1).cloned();
    (manufacturer, subtype)
}

/// Extract plugin name and vendor from PluginConfig in source code.
///
/// Looks for patterns:
/// - `PluginConfig::new("Plugin Name")`
/// - `.with_vendor("Vendor Name")`
///
/// Returns (plugin_name, vendor_name) as Options.
fn detect_plugin_metadata(content: &str) -> (Option<String>, Option<String>) {
    let mut plugin_name = None;
    let mut vendor_name = None;

    // Find PluginConfig::new("name")
    if let Some(start) = content.find("PluginConfig::new(\"") {
        let after_prefix = &content[start + 19..]; // Skip "PluginConfig::new(\""
        if let Some(end) = after_prefix.find('"') {
            plugin_name = Some(after_prefix[..end].to_string());
        }
    }

    // Find .with_vendor("name")
    if let Some(start) = content.find(".with_vendor(\"") {
        let after_prefix = &content[start + 14..]; // Skip ".with_vendor(\""
        if let Some(end) = after_prefix.find('"') {
            vendor_name = Some(after_prefix[..end].to_string());
        }
    }

    (plugin_name, vendor_name)
}

fn get_workspace_root() -> Result<PathBuf, String> {
    let output = Command::new("cargo")
        .args(["locate-project", "--workspace", "--message-format=plain"])
        .output()
        .map_err(|e| format!("Failed to locate workspace: {}", e))?;

    if !output.status.success() {
        return Err("Failed to locate workspace".to_string());
    }

    let cargo_toml = String::from_utf8_lossy(&output.stdout);
    let path = PathBuf::from(cargo_toml.trim());
    path.parent()
        .map(|p| p.to_path_buf())
        .ok_or_else(|| "Invalid workspace path".to_string())
}

fn to_vst3_bundle_name(package: &str) -> String {
    // Convert package name to CamelCase bundle name with Beamer prefix
    // e.g., "gain" -> "BeamerGain.vst3", "midi-transform" -> "BeamerMidiTransform.vst3"
    let name: String = package
        .split('-')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect();
    format!("Beamer{}.vst3", name)
}

/// Returns app bundle name for AUv3
/// e.g., "gain" -> "BeamerGain.app"
fn to_au_bundle_name(package: &str) -> String {
    let name: String = package
        .split('-')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect();
    format!("Beamer{}.app", name)
}

/// Returns component bundle name for AUv2
/// e.g., "gain" -> "BeamerGain.component"
fn to_auv2_component_name(package: &str) -> String {
    let name: String = package
        .split('-')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect();
    format!("Beamer{}.component", name)
}

fn create_vst3_info_plist(package: &str, bundle_name: &str) -> String {
    let executable_name = bundle_name.trim_end_matches(".vst3");

    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>English</string>
    <key>CFBundleExecutable</key>
    <string>{}</string>
    <key>CFBundleIdentifier</key>
    <string>com.beamer.{}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{}</string>
    <key>CFBundlePackageType</key>
    <string>BNDL</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleVersion</key>
    <string>0.2.0</string>
    <key>CFBundleShortVersionString</key>
    <string>0.2.0</string>
</dict>
</plist>
"#,
        executable_name, package, executable_name
    )
}

/// Create Info.plist for container app (stub executable that triggers pluginkit registration)
fn create_app_info_plist(package: &str, executable_name: &str, version: &str) -> String {
    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>English</string>
    <key>CFBundleExecutable</key>
    <string>{executable}</string>
    <key>CFBundleIdentifier</key>
    <string>com.beamer.{package}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{executable}</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleVersion</key>
    <string>{version}</string>
    <key>CFBundleShortVersionString</key>
    <string>{version}</string>
    <key>LSMinimumSystemVersion</key>
    <string>10.13</string>
    <key>LSBackgroundOnly</key>
    <true/>
</dict>
</plist>
"#,
        executable = executable_name,
        package = package,
        version = version
    )
}

/// Map AU component type code to appropriate tags for Info.plist.
///
/// DAWs use these tags for plugin categorization.
fn get_au_tags(component_type: &str) -> &'static str {
    match component_type {
        "aufx" => "Effects",           // Audio effect
        "aumu" => "Synth",             // Music device/instrument
        "aumi" => "MIDI",              // MIDI processor
        "aumf" => "Effects",           // Music effect
        _ => "Effects",                // Default fallback
    }
}

/// Create Info.plist for appex with NSExtension
fn create_appex_info_plist(config: &AppexPlistConfig) -> String {
    let manufacturer = config.manufacturer.unwrap_or("Bemr");
    let subtype = config.subtype.map(|s| s.to_string()).unwrap_or_else(|| {
        let gen: String = config.package.chars().filter(|c| c.is_alphanumeric()).take(4).collect::<String>().to_lowercase();
        if gen.len() < 4 { format!("{:_<4}", gen) } else { gen }
    });

    // Get appropriate tags based on component type
    let tags = get_au_tags(config.component_type);

    // Generate plugin-specific extension class name (implements AUAudioUnitFactory)
    let pascal_name = to_pascal_case(config.package);
    let extension_class = format!("Beamer{}AuExtension", pascal_name);

    // Create the plugin display name from vendor and plugin name
    // Format: "Vendor: Plugin Name" (e.g., "Beamer Framework: Beamer Synth")
    let plugin_display_name = match (config.vendor_name, config.plugin_name) {
        (Some(vendor), Some(name)) => format!("{}: {}", vendor, name),
        (None, Some(name)) => format!("Beamer: {}", name),
        (Some(vendor), None) => format!("{}: {}", vendor, config.executable_name),
        (None, None) => format!("Beamer: {}", config.executable_name),
    };

    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>English</string>
    <key>CFBundleExecutable</key>
    <string>{executable}</string>
    <key>CFBundleIdentifier</key>
    <string>com.beamer.{package}.audiounit</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{executable}</string>
    <key>CFBundleDisplayName</key>
    <string>{display_name}</string>
    <key>CFBundlePackageType</key>
    <string>XPC!</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleSupportedPlatforms</key>
    <array>
        <string>MacOSX</string>
    </array>
    <key>CFBundleVersion</key>
    <string>{version}</string>
    <key>CFBundleShortVersionString</key>
    <string>{version}</string>
    <key>LSMinimumSystemVersion</key>
    <string>10.13</string>
    <key>NSExtension</key>
    <dict>
        <key>NSExtensionPointIdentifier</key>
        <string>com.apple.AudioUnit</string>
        <key>NSExtensionPrincipalClass</key>
        <string>{extension_class}</string>
        <key>NSExtensionAttributes</key>
        <dict>
            <key>AudioComponents</key>
            <array>
                <dict>
                    <key>type</key>
                    <string>{component_type}</string>
                    <key>subtype</key>
                    <string>{subtype}</string>
                    <key>manufacturer</key>
                    <string>{manufacturer}</string>
                    <key>name</key>
                    <string>{plugin_display_name}</string>
                    <key>sandboxSafe</key>
                    <true/>
                    <key>tags</key>
                    <array>
                        <string>{tags}</string>
                    </array>
                    <key>version</key>
                    <integer>{version_int}</integer>
                    <key>description</key>
                    <string>{executable} Audio Unit</string>
                </dict>
            </array>
            <key>AudioComponentBundle</key>
            <string>{framework_bundle_id}</string>
        </dict>
    </dict>
</dict>
</plist>
"#,
        executable = config.executable_name,
        package = config.package,
        extension_class = extension_class,
        manufacturer = manufacturer,
        component_type = config.component_type,
        subtype = subtype,
        tags = tags,
        framework_bundle_id = config.framework_bundle_id,
        version = config.version_string,
        version_int = config.version_int,
        plugin_display_name = plugin_display_name,
        display_name = config.plugin_name.unwrap_or(config.executable_name),
    )
}

/// Create Info.plist for AUv2 .component bundle
fn create_component_info_plist(config: &ComponentPlistConfig) -> String {
    let manufacturer = config.manufacturer.unwrap_or("Bemr");
    let subtype = config.subtype.map(|s| s.to_string()).unwrap_or_else(|| {
        let gen: String = config.package.chars().filter(|c| c.is_alphanumeric()).take(4).collect::<String>().to_lowercase();
        if gen.len() < 4 { format!("{:_<4}", gen) } else { gen }
    });

    // Get appropriate tags based on component type
    let tags = get_au_tags(config.component_type);

    // Generate factory function name
    let pascal_name = to_pascal_case(config.package);
    let factory_name = format!("Beamer{}Factory", pascal_name);

    // Create the plugin display name from vendor and plugin name
    let plugin_display_name = match (config.vendor_name, config.plugin_name) {
        (Some(vendor), Some(name)) => format!("{}: {}", vendor, name),
        (None, Some(name)) => format!("Beamer: {}", name),
        (Some(vendor), None) => format!("{}: {}", vendor, config.executable_name),
        (None, None) => format!("Beamer: {}", config.executable_name),
    };

    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>English</string>
    <key>CFBundleExecutable</key>
    <string>{executable}</string>
    <key>CFBundleIdentifier</key>
    <string>com.beamer.{package}.component</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{executable}</string>
    <key>CFBundleDisplayName</key>
    <string>{display_name}</string>
    <key>CFBundlePackageType</key>
    <string>BNDL</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleSupportedPlatforms</key>
    <array>
        <string>MacOSX</string>
    </array>
    <key>CFBundleVersion</key>
    <string>{version}</string>
    <key>CFBundleShortVersionString</key>
    <string>{version}</string>
    <key>LSMinimumSystemVersion</key>
    <string>10.13</string>
    <key>AudioComponents</key>
    <array>
        <dict>
            <key>type</key>
            <string>{component_type}</string>
            <key>subtype</key>
            <string>{subtype}</string>
            <key>manufacturer</key>
            <string>{manufacturer}</string>
            <key>name</key>
            <string>{plugin_display_name}</string>
            <key>description</key>
            <string>{executable} Audio Unit</string>
            <key>factoryFunction</key>
            <string>{factory_name}</string>
            <key>sandboxSafe</key>
            <true/>
            <key>tags</key>
            <array>
                <string>{tags}</string>
            </array>
            <key>version</key>
            <integer>{version_int}</integer>
        </dict>
    </array>
</dict>
</plist>
"#,
        executable = config.executable_name,
        package = config.package,
        manufacturer = manufacturer,
        component_type = config.component_type,
        subtype = subtype,
        tags = tags,
        factory_name = factory_name,
        version = config.version_string,
        version_int = config.version_int,
        plugin_display_name = plugin_display_name,
        display_name = config.plugin_name.unwrap_or(config.executable_name),
    )
}

fn install_vst3(bundle_dir: &Path, bundle_name: &str, verbose: bool) -> Result<(), String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set")?;
    let vst3_dir = PathBuf::from(home)
        .join("Library")
        .join("Audio")
        .join("Plug-Ins")
        .join("VST3");

    // Create VST3 directory if needed
    fs::create_dir_all(&vst3_dir).map_err(|e| format!("Failed to create VST3 dir: {}", e))?;

    let dest = vst3_dir.join(bundle_name);

    // Remove existing installation
    if dest.exists() {
        fs::remove_dir_all(&dest).map_err(|e| format!("Failed to remove old installation: {}", e))?;
    }

    // Copy bundle
    copy_dir_all(bundle_dir, &dest)?;

    verbose!(verbose, "    Installed to: {}", dest.display());
    status!("âœ“ {} â†’ {}", bundle_name, shorten_path(&dest));
    Ok(())
}

fn install_auv2(bundle_dir: &Path, bundle_name: &str, verbose: bool) -> Result<(), String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set")?;

    // AUv2 components go to ~/Library/Audio/Plug-Ins/Components/
    let components_dir = PathBuf::from(&home)
        .join("Library")
        .join("Audio")
        .join("Plug-Ins")
        .join("Components");

    // Create Components directory if needed
    fs::create_dir_all(&components_dir)
        .map_err(|e| format!("Failed to create Components dir: {}", e))?;

    let dest = components_dir.join(bundle_name);

    // Remove existing installation
    if dest.exists() {
        fs::remove_dir_all(&dest).map_err(|e| format!("Failed to remove old installation: {}", e))?;
    }

    // Copy bundle
    copy_dir_all(bundle_dir, &dest)?;

    verbose!(verbose, "    Installed to: {}", dest.display());

    // Refresh AU cache to pick up the new component
    let killall_result = Command::new("killall")
        .arg("-9")
        .arg("AudioComponentRegistrar")
        .output();

    if verbose {
        if let Ok(output) = killall_result {
            let stderr = String::from_utf8_lossy(&output.stderr);
            for line in stderr.lines() {
                verbose!(verbose, "    {}", line);
            }
        }
    }
    verbose!(verbose, "    Audio Unit cache refreshed");
    status!("âœ“ {} â†’ {}", bundle_name, shorten_path(&dest));

    Ok(())
}

fn install_au(bundle_dir: &Path, bundle_name: &str, verbose: bool) -> Result<(), String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set")?;

    // AUv3 app extensions must be installed as apps (not in Components folder).
    // The system discovers them when the containing app is launched.
    let au_dir = PathBuf::from(&home).join("Applications");

    // Create Applications directory if needed
    fs::create_dir_all(&au_dir).map_err(|e| format!("Failed to create Applications dir: {}", e))?;

    let dest = au_dir.join(bundle_name);

    // Remove existing installation
    if dest.exists() {
        fs::remove_dir_all(&dest).map_err(|e| format!("Failed to remove old installation: {}", e))?;
    }

    // Copy bundle
    copy_dir_all(bundle_dir, &dest)?;

    verbose!(verbose, "    Installed to: {}", dest.display());

    // Launch the app briefly to trigger pluginkit registration.
    // AUv3 extensions are registered when their containing app is first launched.
    verbose!(verbose, "    Registering Audio Unit extension...");
    let _ = Command::new("open")
        .arg(&dest)
        .status();

    // Give the system a moment to register the extension
    std::thread::sleep(std::time::Duration::from_millis(500));

    // Terminate the background app (it has LSBackgroundOnly so it won't show UI)
    let executable_name = bundle_name.trim_end_matches(".app");
    let killall_app = Command::new("killall")
        .arg(executable_name)
        .output();

    if verbose {
        if let Ok(output) = killall_app {
            let stderr = String::from_utf8_lossy(&output.stderr);
            for line in stderr.lines() {
                verbose!(verbose, "    {}", line);
            }
        }
    }

    // Also refresh AU cache
    let killall_au = Command::new("killall")
        .arg("-9")
        .arg("AudioComponentRegistrar")
        .output();

    if verbose {
        if let Ok(output) = killall_au {
            let stderr = String::from_utf8_lossy(&output.stderr);
            for line in stderr.lines() {
                verbose!(verbose, "    {}", line);
            }
        }
    }
    verbose!(verbose, "    Audio Unit registered");
    status!("âœ“ {} â†’ {}", bundle_name, shorten_path(&dest));

    Ok(())
}

fn copy_dir_all(src: &Path, dst: &Path) -> Result<(), String> {
    fs::create_dir_all(dst).map_err(|e| format!("Failed to create dir: {}", e))?;

    for entry in fs::read_dir(src).map_err(|e| format!("Failed to read dir: {}", e))? {
        let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
        let ty = entry
            .file_type()
            .map_err(|e| format!("Failed to get file type: {}", e))?;

        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if ty.is_dir() {
            copy_dir_all(&src_path, &dst_path)?;
        } else if ty.is_symlink() {
            // Preserve symlinks (important for AUv3 container app binary)
            #[cfg(unix)]
            {
                let target = fs::read_link(&src_path)
                    .map_err(|e| format!("Failed to read symlink: {}", e))?;
                std::os::unix::fs::symlink(&target, &dst_path)
                    .map_err(|e| format!("Failed to create symlink: {}", e))?;
            }
            #[cfg(not(unix))]
            {
                fs::copy(&src_path, &dst_path)
                    .map_err(|e| format!("Failed to copy file: {}", e))?;
            }
        } else {
            fs::copy(&src_path, &dst_path)
                .map_err(|e| format!("Failed to copy file: {}", e))?;
        }
    }

    Ok(())
}
