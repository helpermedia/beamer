// DO NOT EDIT - Generated by xtask
//
// AUv3 extension for plugins WITH a GUI.
// Inherits AUViewController (CoreAudioKit) so Logic Pro shows custom UI.

@import AudioToolbox;
@import CoreAudioKit;
@import Foundation;
#include "BeamerAuBridge.h"
#include "au_ipc_helpers.h"

@class {{WRAPPER_CLASS}};

@interface {{WRAPPER_CLASS}} : AUAudioUnit
- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError;
- (BeamerAuInstanceHandle)rustInstance;
@end

@interface {{EXTENSION_CLASS}} : AUViewController <AUAudioUnitFactory>
{
@public
    void* _webviewHandle;
    uint32_t _guiWidth;
    uint32_t _guiHeight;
    {{WRAPPER_CLASS}}* _wrapper;
    NSTimer* _syncTimer;
    BOOL _webviewLoaded;
    double* _lastParamValues;
    uint32_t _paramCount;
}
@end

@interface {{EXTENSION_CLASS}} ()
- (void)_ensureWebView;
- (void)_sendInitDump;
- (void)_startSyncTimer;
- (void)_pollParams;
@end

// =============================================================================
// MARK: - WebView IPC Callbacks
// =============================================================================

static void beamer_auv3_ext_on_message(void* context, const uint8_t* json, size_t len) {
    {{EXTENSION_CLASS}}* ext = (__bridge {{EXTENSION_CLASS}}*)context;
    BeamerAuInstanceHandle instance = [ext->_wrapper rustInstance];
    if (!instance) return;

    NSString* jsonStr = [[NSString alloc] initWithBytes:json length:len encoding:NSUTF8StringEncoding];
    if (!jsonStr) return;

    NSData* data = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];
    NSDictionary* msg = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
    if (!msg) return;

    NSString* type = msg[@"type"];
    if ([type isEqualToString:@"param:set"]) {
        uint32_t paramId = [msg[@"id"] unsignedIntValue];
        double value = [msg[@"value"] doubleValue];
        beamer_au_param_set_from_ui(instance, paramId, value);
        AUParameter* param = [ext->_wrapper.parameterTree parameterWithAddress:(AUParameterAddress)paramId];
        if (param) {
            float min = param.minValue;
            float max = param.maxValue;
            param.value = min + (float)value * (max - min);
        }
    } else if ([type isEqualToString:@"param:begin"]) {
        uint32_t paramId = [msg[@"id"] unsignedIntValue];
        AUParameter* param = [ext->_wrapper.parameterTree parameterWithAddress:(AUParameterAddress)paramId];
        if (param) {
            [param setValue:param.value originator:nil atHostTime:0 eventType:AUParameterAutomationEventTypeTouch];
        }
    } else if ([type isEqualToString:@"param:end"]) {
        uint32_t paramId = [msg[@"id"] unsignedIntValue];
        AUParameter* param = [ext->_wrapper.parameterTree parameterWithAddress:(AUParameterAddress)paramId];
        if (param) {
            [param setValue:param.value originator:nil atHostTime:0 eventType:AUParameterAutomationEventTypeRelease];
        }
    } else if ([type isEqualToString:@"invoke"]) {
        beamer_au_ipc_handle_invoke(instance, ext->_webviewHandle, msg);
    } else if ([type isEqualToString:@"event"]) {
        beamer_au_ipc_handle_event(instance, msg);
    }
}

static void beamer_auv3_ext_on_loaded(void* context) {
    {{EXTENSION_CLASS}}* ext = (__bridge {{EXTENSION_CLASS}}*)context;
    ext->_webviewLoaded = YES;

    // If the wrapper is already available, send the parameter init dump
    // and start the sync timer. Otherwise createAudioUnitWithComponentDescription:
    // will handle it when the wrapper arrives.
    if (ext->_wrapper) {
        [ext _sendInitDump];
        [ext _startSyncTimer];
    }
}

// =============================================================================
// MARK: - Extension Implementation
// =============================================================================

@implementation {{EXTENSION_CLASS}}

- (instancetype)initWithNibName:(NSNibName)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        beamer_au_ensure_factory_registered();
        beamer_au_get_gui_size(NULL, &_guiWidth, &_guiHeight);
        self.preferredContentSize = NSMakeSize(_guiWidth, _guiHeight);
    }
    return self;
}

- (void)loadView {
    NSView* container = [[NSView alloc]
        initWithFrame:NSMakeRect(0, 0, _guiWidth, _guiHeight)];
    self.view = container;
    self.preferredContentSize = NSMakeSize(_guiWidth, _guiHeight);

    // Create the WebView early so content can load before the host
    // shows the window, matching the timing VST3 and AUv2 get.
    [self _ensureWebView];
}

- (void)viewWillAppear {
    [super viewWillAppear];

    // Recreate the WebView if it was destroyed on close.
    [self _ensureWebView];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Keep frame-based layout; pin to top-left
    self.view.translatesAutoresizingMaskIntoConstraints = YES;
    self.view.autoresizingMask = NSViewMaxXMargin | NSViewMinYMargin;
}

- (void)_ensureWebView {
    if (_webviewHandle != NULL) {
        return;
    }

#ifdef DEBUG
    bool devTools = true;
#else
    bool devTools = false;
#endif

    uint8_t pluginCode[4];
    beamer_au_get_plugin_code(pluginCode);

    uint8_t bgColor[4];
    beamer_au_get_gui_background_color(bgColor);

    // Always create with IPC callbacks. The callbacks check whether
    // _wrapper is available before accessing the Rust instance, so
    // it's safe even if the audio unit hasn't been created yet.
    const char* devUrl = beamer_au_get_gui_url(NULL);
    if (devUrl != NULL) {
        _webviewHandle = beamer_webview_create_url_with_ipc(
            (__bridge void*)self.view, devUrl, pluginCode, devTools, bgColor,
            beamer_auv3_ext_on_message, beamer_auv3_ext_on_loaded,
            (__bridge void*)self);
    } else {
        const void* assets = beamer_au_get_gui_assets();
        _webviewHandle = beamer_webview_create_with_ipc(
            (__bridge void*)self.view, assets, pluginCode, devTools, bgColor,
            beamer_auv3_ext_on_message, beamer_auv3_ext_on_loaded,
            (__bridge void*)self);
    }
}

- (void)_sendInitDump {
    if (!_webviewHandle || !_wrapper) return;
    BeamerAuInstanceHandle instance = [_wrapper rustInstance];
    beamer_au_ipc_send_init_dump(instance, _webviewHandle);
}

- (void)_startSyncTimer {
    if (_syncTimer) return;

    // NAN sentinel: NAN != NAN (IEEE 754) ensures the first sync tick sends all values.
    BeamerAuInstanceHandle instance = [_wrapper rustInstance];
    if (instance) {
        _paramCount = beamer_au_get_parameter_count(instance);
        if (_paramCount > 0) {
            free(_lastParamValues);
            _lastParamValues = (double*)malloc(_paramCount * sizeof(double));
            for (uint32_t i = 0; i < _paramCount; i++) {
                _lastParamValues[i] = NAN;
            }
        }
    }

    // Use __weak to avoid a retain cycle (self -> _syncTimer -> block -> self).
    __weak typeof(self) weakSelf = self;
    _syncTimer = [NSTimer scheduledTimerWithTimeInterval:1.0/60.0 repeats:YES block:^(NSTimer* t) {
        (void)t;
        [weakSelf _pollParams];
    }];
}

- (void)_pollParams {
    if (!_webviewHandle || !_wrapper) return;
    BeamerAuInstanceHandle instance = [_wrapper rustInstance];
    if (!instance) return;
    if (_paramCount == 0) return;

    NSMutableString* script = [NSMutableString stringWithString:@"window.__BEAMER__._onParams({"];
    BOOL any = NO;

    BeamerAuParameterInfo info;
    for (uint32_t i = 0; i < _paramCount; i++) {
        if (!beamer_au_get_parameter_info(instance, i, &info)) continue;
        double val = beamer_au_param_get_normalized(instance, info.id);
        if (val == _lastParamValues[i]) continue;
        _lastParamValues[i] = val;
        if (any) [script appendString:@","];
        [script appendFormat:@"%u:%f", info.id, val];
        any = YES;
    }

    if (any) {
        [script appendString:@"})"];
        const char* utf8 = [script UTF8String];
        beamer_webview_eval_js(_webviewHandle, (const uint8_t*)utf8, strlen(utf8));
    }
}

- (void)viewDidLayout {
    [super viewDidLayout];
    if (_webviewHandle != NULL) {
        CGSize size = self.view.frame.size;
        beamer_webview_set_frame(_webviewHandle, 0, 0,
            (int32_t)size.width, (int32_t)size.height);
    }
}

- (void)viewDidDisappear {
    [super viewDidDisappear];

    [_syncTimer invalidate];
    _syncTimer = nil;
    _webviewLoaded = NO;
    free(_lastParamValues);
    _lastParamValues = NULL;
    _paramCount = 0;

    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (void)dealloc {
    // Safety net in case -viewDidDisappear was not called
    [_syncTimer invalidate];
    _syncTimer = nil;
    free(_lastParamValues);
    _lastParamValues = NULL;

    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (AUAudioUnit *)createAudioUnitWithComponentDescription:(AudioComponentDescription)desc
                                                   error:(NSError **)error {
    if (!beamer_au_ensure_factory_registered()) {
        if (error) {
            *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                         code:kAudioUnitErr_FailedInitialization
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to register plugin factory"}];
        }
        return nil;
    }

    {{WRAPPER_CLASS}}* wrapper = [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:desc options:0 error:error];
    if (!wrapper) return nil;

    _wrapper = wrapper;

    // If the WebView already finished loading, send the init dump and
    // start the parameter sync timer now. Otherwise the on_loaded
    // callback will handle it when the load completes.
    if (_webviewLoaded && _webviewHandle) {
        [self _sendInitDump];
        [self _startSyncTimer];
    }

    return wrapper;
}

@end

void beamer_au_appex_force_link(void) {
    (void)[{{EXTENSION_CLASS}} class];
}

void* {{FACTORY_FUNC}}(const AudioComponentDescription* desc) {
    if (!beamer_au_ensure_factory_registered()) {
        return NULL;
    }
    NSError* error = nil;
    {{WRAPPER_CLASS}}* wrapper = [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:*desc
                                                                             options:0
                                                                               error:&error];
    if (error) {
        return NULL;
    }
    return (__bridge_retained void*)wrapper;
}
