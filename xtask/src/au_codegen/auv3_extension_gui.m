// DO NOT EDIT - Generated by xtask
//
// AUv3 extension for plugins WITH a GUI.
// Inherits AUViewController (CoreAudioKit) so Logic Pro shows custom UI.

@import AudioToolbox;
@import CoreAudioKit;
@import Foundation;
#include "BeamerAuBridge.h"

@class {{WRAPPER_CLASS}};

@interface {{WRAPPER_CLASS}} : AUAudioUnit
- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError;
@end

@interface {{EXTENSION_CLASS}} : AUViewController <AUAudioUnitFactory>
{
    void* _webviewHandle;
    uint32_t _guiWidth;
    uint32_t _guiHeight;
}
@end

@implementation {{EXTENSION_CLASS}}

- (instancetype)initWithNibName:(NSNibName)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        beamer_au_ensure_factory_registered();
        beamer_au_get_gui_size(NULL, &_guiWidth, &_guiHeight);
        self.preferredContentSize = NSMakeSize(_guiWidth, _guiHeight);
    }
    return self;
}

- (void)loadView {
    NSView* container = [[NSView alloc]
        initWithFrame:NSMakeRect(0, 0, _guiWidth, _guiHeight)];
    self.view = container;
    self.preferredContentSize = NSMakeSize(_guiWidth, _guiHeight);

    // Create the WebView early so content can load before the host
    // shows the window, matching the timing VST3 and AUv2 get.
    [self _ensureWebView];
}

- (void)viewWillAppear {
    [super viewWillAppear];

    // Recreate the WebView if it was destroyed on close.
    [self _ensureWebView];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Keep frame-based layout; pin to top-left
    self.view.translatesAutoresizingMaskIntoConstraints = YES;
    self.view.autoresizingMask = NSViewMaxXMargin | NSViewMinYMargin;
}

- (void)_ensureWebView {
    if (_webviewHandle != NULL) {
        return;
    }

#ifdef DEBUG
    bool devTools = true;
#else
    bool devTools = false;
#endif

    uint8_t pluginCode[4];
    beamer_au_get_plugin_code(pluginCode);

    uint8_t bgColor[4];
    beamer_au_get_gui_background_color(bgColor);

    const char* devUrl = beamer_au_get_gui_url(NULL);
    if (devUrl != NULL) {
        _webviewHandle = beamer_webview_create_url(
            (__bridge void*)self.view, devUrl, pluginCode, devTools, bgColor);
    } else {
        const void* assets = beamer_au_get_gui_assets();
        _webviewHandle = beamer_webview_create(
            (__bridge void*)self.view, assets, pluginCode, devTools, bgColor);
    }
}

- (void)viewDidLayout {
    [super viewDidLayout];
    if (_webviewHandle != NULL) {
        CGSize size = self.view.frame.size;
        beamer_webview_set_frame(_webviewHandle, 0, 0,
            (int32_t)size.width, (int32_t)size.height);
    }
}

- (void)viewDidDisappear {
    [super viewDidDisappear];

    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (void)dealloc {
    // Safety net in case -viewDidDisappear was not called
    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (AUAudioUnit *)createAudioUnitWithComponentDescription:(AudioComponentDescription)desc
                                                   error:(NSError **)error {
    if (!beamer_au_ensure_factory_registered()) {
        if (error) {
            *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                         code:kAudioUnitErr_FailedInitialization
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to register plugin factory"}];
        }
        return nil;
    }

    return [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:desc options:0 error:error];
}

@end

void beamer_au_appex_force_link(void) {
    (void)[{{EXTENSION_CLASS}} class];
}

void* {{FACTORY_FUNC}}(const AudioComponentDescription* desc) {
    if (!beamer_au_ensure_factory_registered()) {
        return NULL;
    }
    NSError* error = nil;
    {{WRAPPER_CLASS}}* wrapper = [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:*desc
                                                                             options:0
                                                                               error:&error];
    if (error) {
        return NULL;
    }
    return (__bridge_retained void*)wrapper;
}
