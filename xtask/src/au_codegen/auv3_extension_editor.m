// DO NOT EDIT - Generated by xtask
//
// AUv3 extension for plugins WITH an editor.
// Inherits AUViewController (CoreAudioKit) so Logic Pro shows custom UI.

@import AudioToolbox;
@import CoreAudioKit;
@import Foundation;
#include "BeamerAuBridge.h"

@class {{WRAPPER_CLASS}};

@interface {{WRAPPER_CLASS}} : AUAudioUnit
- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError;
@end

@interface {{EXTENSION_CLASS}} : AUViewController <AUAudioUnitFactory>
{
    void* _webviewHandle;
    uint32_t _editorWidth;
    uint32_t _editorHeight;
}
@end

@implementation {{EXTENSION_CLASS}}

- (instancetype)initWithNibName:(NSNibName)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        beamer_au_ensure_factory_registered();
        beamer_au_get_editor_size(NULL, &_editorWidth, &_editorHeight);
        self.preferredContentSize = NSMakeSize(_editorWidth, _editorHeight);
    }
    return self;
}

- (void)loadView {
    NSView* container = [[NSView alloc]
        initWithFrame:NSMakeRect(0, 0, _editorWidth, _editorHeight)];
    self.view = container;
    self.preferredContentSize = NSMakeSize(_editorWidth, _editorHeight);
}

- (void)viewWillAppear {
    [super viewWillAppear];

    if (_webviewHandle != NULL) {
        return; // Already created
    }

    const char* html = beamer_au_get_editor_html(NULL);
    if (html == NULL) {
        return;
    }

#ifdef DEBUG
    bool devTools = true;
#else
    bool devTools = false;
#endif
    _webviewHandle = beamer_webview_create(
        (__bridge void*)self.view, html, devTools);
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Keep frame-based layout; pin to top-left
    self.view.translatesAutoresizingMaskIntoConstraints = YES;
    self.view.autoresizingMask = NSViewMaxXMargin | NSViewMinYMargin;
}

- (void)viewDidLayout {
    [super viewDidLayout];
    if (_webviewHandle != NULL) {
        CGSize size = self.view.frame.size;
        beamer_webview_set_frame(_webviewHandle, 0, 0,
            (int32_t)size.width, (int32_t)size.height);
    }
}

- (void)viewDidDisappear {
    [super viewDidDisappear];

    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (void)dealloc {
    // Safety net in case -viewDidDisappear was not called
    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }
}

- (AUAudioUnit *)createAudioUnitWithComponentDescription:(AudioComponentDescription)desc
                                                   error:(NSError **)error {
    if (!beamer_au_ensure_factory_registered()) {
        if (error) {
            *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                         code:kAudioUnitErr_FailedInitialization
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to register plugin factory"}];
        }
        return nil;
    }

    return [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:desc options:0 error:error];
}

@end

void beamer_au_appex_force_link(void) {
    (void)[{{EXTENSION_CLASS}} class];
}

void* {{FACTORY_FUNC}}(const AudioComponentDescription* desc) {
    if (!beamer_au_ensure_factory_registered()) {
        return NULL;
    }
    NSError* error = nil;
    {{WRAPPER_CLASS}}* wrapper = [[{{WRAPPER_CLASS}} alloc] initWithComponentDescription:*desc
                                                                             options:0
                                                                               error:&error];
    if (error) {
        return NULL;
    }
    return (__bridge_retained void*)wrapper;
}
