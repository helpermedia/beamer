// DO NOT EDIT - Generated by xtask

#import <AudioToolbox/AudioToolbox.h>
#import <AVFoundation/AVFoundation.h>
#import <Cocoa/Cocoa.h>
#import <CoreAudioKit/CoreAudioKit.h>
#import <Foundation/Foundation.h>
#include <os/lock.h>
#include <os/log.h>

#include "BeamerAuBridge.h"

// =============================================================================
// MARK: - Constants
// =============================================================================

static const double kDefaultSampleRate = 44100.0;
static const AUAudioFrameCount kDefaultMaxFrames = 4096;

// =============================================================================
// MARK: - {{WRAPPER_CLASS}} Interface
// =============================================================================

@interface {{WRAPPER_CLASS}} : AUAudioUnit {
    BeamerAuInstanceHandle _rustInstance;
    NSLock* _instanceLock;
    BOOL _instanceValid;
    AUParameterTree* _parameterTree;
    BeamerAuSampleFormat _sampleFormat;
    double _sampleRate;
    AUAudioFrameCount _maxFrames;
    BOOL _resourcesAllocated;
    BeamerAuBusConfig _busConfig;
    NSUInteger _instanceId;
    AVAudioPCMBuffer* _inputPCMBuffer;
    AudioBufferList* _inputMutableABL;
    AUAudioUnitPreset* _currentPreset;
    AUInternalRenderBlock _cachedInternalRenderBlock;
    NSArray<AUAudioUnitPreset*>* _factoryPresets;
    void* _webviewHandle;
}

+ (NSUInteger)nextInstanceId;

@end

@interface {{WRAPPER_CLASS}} ()
@property (nonatomic) AUAudioUnitBusArray* inputBusArray;
@property (nonatomic) AUAudioUnitBusArray* outputBusArray;
@end

static NSUInteger {{WRAPPER_CLASS}}InstanceCounter = 0;

@implementation {{WRAPPER_CLASS}}

@synthesize parameterTree = _parameterTree;
@synthesize factoryPresets = _factoryPresets;
@synthesize inputBusArray = _inputBusArray;
@synthesize outputBusArray = _outputBusArray;

+ (NSUInteger)nextInstanceId {
    @synchronized([{{WRAPPER_CLASS}} class]) {
        return ++{{WRAPPER_CLASS}}InstanceCounter;
    }
}

- (instancetype)initWithComponentDescription:(AudioComponentDescription)componentDescription
                                     options:(AudioComponentInstantiationOptions)options
                                       error:(NSError**)outError {
    NSUInteger instanceId = [[self class] nextInstanceId];

    if (!beamer_au_ensure_factory_registered()) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FailedInitialization
                                        userInfo:@{NSLocalizedDescriptionKey: @"Failed to register Rust plugin factory"}];
        }
        return nil;
    }

    self = [super initWithComponentDescription:componentDescription
                                       options:options
                                         error:outError];

    if (self == nil) {
        return nil;
    }

    if (outError != NULL) {
        *outError = nil;
    }

    _instanceId = instanceId;
    _rustInstance = NULL;
    _instanceLock = [[NSLock alloc] init];
    _instanceValid = NO;
    _inputBusArray = nil;
    _outputBusArray = nil;
    _parameterTree = nil;
    _factoryPresets = nil;
    _sampleFormat = BeamerAuSampleFormatFloat32;
    _sampleRate = kDefaultSampleRate;
    _maxFrames = kDefaultMaxFrames;
    _resourcesAllocated = NO;
    _webviewHandle = NULL;
    memset(&_busConfig, 0, sizeof(_busConfig));

    AUAudioUnitPreset* defaultPreset = [[AUAudioUnitPreset alloc] init];
    defaultPreset.number = 0;
    defaultPreset.name = @"Default";
    _currentPreset = defaultPreset;

    _rustInstance = beamer_au_create_instance();
    if (_rustInstance == NULL) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FailedInitialization
                                        userInfo:@{NSLocalizedDescriptionKey: @"Failed to create Rust plugin instance"}];
        }
        return nil;
    }

    _instanceValid = YES;

    if (![self setupBusArraysWithError:outError]) {
        _instanceValid = NO;
        beamer_au_destroy_instance(_rustInstance);
        _rustInstance = NULL;
        return nil;
    }

    (void)[self internalRenderBlock];

    return self;
}

- (void)dealloc {
    [_instanceLock lock];
    _instanceValid = NO;

    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }

    if (_rustInstance != NULL) {
        if (_resourcesAllocated) {
            beamer_au_deallocate_render_resources(_rustInstance);
            _resourcesAllocated = NO;
        }
        beamer_au_destroy_instance(_rustInstance);
        _rustInstance = NULL;
    }

    [_instanceLock unlock];
}

- (AUAudioUnitBus*)createBusAtIndex:(uint32_t)index
                            isInput:(BOOL)isInput
                      defaultFormat:(AVAudioFormat*)defaultFormat
                              error:(NSError**)outError {
    uint32_t channelCount = isInput
        ? beamer_au_get_input_bus_channel_count(_rustInstance, index)
        : beamer_au_get_output_bus_channel_count(_rustInstance, index);

    if (channelCount == 0) channelCount = 2;
    if (channelCount > BEAMER_AU_MAX_CHANNELS) channelCount = BEAMER_AU_MAX_CHANNELS;

    AVAudioFormat* format = [[AVAudioFormat alloc]
        initStandardFormatWithSampleRate:kDefaultSampleRate
                                channels:(AVAudioChannelCount)channelCount];
    if (format == nil) {
        format = defaultFormat;
    }

    NSError* busError = nil;
    AUAudioUnitBus* bus = [[AUAudioUnitBus alloc] initWithFormat:format error:&busError];
    if (bus == nil) {
        if (outError != NULL) {
            *outError = busError;
        }
        return nil;
    }

    bus.maximumChannelCount = BEAMER_AU_MAX_CHANNELS;

    if (isInput) {
        bus.name = (index == 0) ? @"Main Input" : [NSString stringWithFormat:@"Aux Input %u", index];
    } else {
        bus.name = (index == 0) ? @"Main Output" : [NSString stringWithFormat:@"Aux Output %u", index];
    }

    return bus;
}

- (BOOL)setupBusArraysWithError:(NSError**)outError {
    if (_rustInstance == NULL) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_Uninitialized
                                        userInfo:@{NSLocalizedDescriptionKey: @"Rust instance not initialized"}];
        }
        return NO;
    }

    uint32_t inputBusCount = beamer_au_get_input_bus_count(_rustInstance);
    uint32_t outputBusCount = beamer_au_get_output_bus_count(_rustInstance);

    if (inputBusCount > BEAMER_AU_MAX_BUSES) inputBusCount = BEAMER_AU_MAX_BUSES;
    if (outputBusCount > BEAMER_AU_MAX_BUSES) outputBusCount = BEAMER_AU_MAX_BUSES;

    if (inputBusCount == 0 && outputBusCount == 0) {
        outputBusCount = 1;
    }

    AVAudioFormat* stereoFormat = [[AVAudioFormat alloc]
        initStandardFormatWithSampleRate:kDefaultSampleRate
                                channels:2];

    NSMutableArray<AUAudioUnitBus*>* inputBuses = [[NSMutableArray alloc] initWithCapacity:inputBusCount];
    for (uint32_t i = 0; i < inputBusCount; i++) {
        AUAudioUnitBus* bus = [self createBusAtIndex:i
                                             isInput:YES
                                       defaultFormat:stereoFormat
                                               error:outError];
        if (bus == nil) {
            return NO;
        }
        [inputBuses addObject:bus];
    }

    NSMutableArray<AUAudioUnitBus*>* outputBuses = [[NSMutableArray alloc] initWithCapacity:outputBusCount];
    for (uint32_t i = 0; i < outputBusCount; i++) {
        AUAudioUnitBus* bus = [self createBusAtIndex:i
                                             isInput:NO
                                       defaultFormat:stereoFormat
                                               error:outError];
        if (bus == nil) {
            return NO;
        }
        [outputBuses addObject:bus];
    }

    _inputBusArray = [[AUAudioUnitBusArray alloc] initWithAudioUnit:self
                                                           busType:AUAudioUnitBusTypeInput
                                                            busses:inputBuses];
    _outputBusArray = [[AUAudioUnitBusArray alloc] initWithAudioUnit:self
                                                            busType:AUAudioUnitBusTypeOutput
                                                             busses:outputBuses];

    return YES;
}

- (void)buildBusConfig {
    memset(&_busConfig, 0, sizeof(_busConfig));

    _busConfig.input_bus_count = (uint32_t)_inputBusArray.count;
    for (uint32_t i = 0; i < _busConfig.input_bus_count && i < BEAMER_AU_MAX_BUSES; i++) {
        _busConfig.input_buses[i].channel_count = (uint32_t)_inputBusArray[i].format.channelCount;
        _busConfig.input_buses[i].bus_type = (i == 0) ? BeamerAuBusTypeMain : BeamerAuBusTypeAuxiliary;
    }

    _busConfig.output_bus_count = (uint32_t)_outputBusArray.count;
    for (uint32_t i = 0; i < _busConfig.output_bus_count && i < BEAMER_AU_MAX_BUSES; i++) {
        _busConfig.output_buses[i].channel_count = (uint32_t)_outputBusArray[i].format.channelCount;
        _busConfig.output_buses[i].bus_type = (i == 0) ? BeamerAuBusTypeMain : BeamerAuBusTypeAuxiliary;
    }
}

- (AUAudioUnitBusArray*)inputBusses {
    return _inputBusArray;
}

- (AUAudioUnitBusArray*)outputBusses {
    return _outputBusArray;
}

- (BOOL)shouldChangeToFormat:(AVAudioFormat*)format forBus:(AUAudioUnitBus*)bus {
    BeamerAuChannelCapabilities caps;
    if (!beamer_au_get_channel_capabilities(_rustInstance, &caps)) {
        return [super shouldChangeToFormat:format forBus:bus];
    }

    if (caps.count == 0) {
        return [super shouldChangeToFormat:format forBus:bus];
    }

    BOOL isInput = NO;
    NSUInteger busIndex = NSNotFound;

    for (NSUInteger i = 0; i < _inputBusArray.count; i++) {
        if (_inputBusArray[i] == bus) {
            isInput = YES;
            busIndex = i;
            break;
        }
    }

    if (busIndex == NSNotFound) {
        for (NSUInteger i = 0; i < _outputBusArray.count; i++) {
            if (_outputBusArray[i] == bus) {
                isInput = NO;
                busIndex = i;
                break;
            }
        }
    }

    if (busIndex != 0) {
        return [super shouldChangeToFormat:format forBus:bus];
    }

    uint32_t newChannelCount = (uint32_t)format.channelCount;
    uint32_t inputChannels = isInput ? newChannelCount : (uint32_t)(_inputBusArray.count > 0 ? _inputBusArray[0].format.channelCount : 0);
    uint32_t outputChannels = isInput ? (uint32_t)(_outputBusArray.count > 0 ? _outputBusArray[0].format.channelCount : 0) : newChannelCount;

    for (uint32_t i = 0; i < caps.count; i++) {
        int32_t capInput = caps.capabilities[i].input_channels;
        int32_t capOutput = caps.capabilities[i].output_channels;

        BOOL inputMatches = (capInput == -1) || (capInput == (int32_t)inputChannels);
        BOOL outputMatches = (capOutput == -1) || (capOutput == (int32_t)outputChannels);

        if (capInput == -1 && capOutput == -1) {
            if (inputChannels == outputChannels) {
                return [super shouldChangeToFormat:format forBus:bus];
            }
        } else if (inputMatches && outputMatches) {
            return [super shouldChangeToFormat:format forBus:bus];
        }
    }

    return NO;
}

- (BOOL)allocateRenderResourcesAndReturnError:(NSError**)outError {
    if (_rustInstance == NULL) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_Uninitialized
                                        userInfo:@{NSLocalizedDescriptionKey: @"Rust instance not initialized"}];
        }
        return NO;
    }

    if (![super allocateRenderResourcesAndReturnError:outError]) {
        return NO;
    }

    [self buildBusConfig];

    uint32_t mainInputChannels = (_busConfig.input_bus_count > 0) ? _busConfig.input_buses[0].channel_count : 0;
    uint32_t mainOutputChannels = (_busConfig.output_bus_count > 0) ? _busConfig.output_buses[0].channel_count : 0;

    if (!beamer_au_is_channel_config_valid(_rustInstance, mainInputChannels, mainOutputChannels)) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:kAudioUnitErr_FormatNotSupported
                                        userInfo:@{NSLocalizedDescriptionKey: @"Channel configuration not supported"}];
        }
        self.renderResourcesAllocated = NO;
        [super deallocateRenderResources];
        return NO;
    }

    AVAudioFormat* format = nil;
    if (_outputBusArray.count > 0) {
        format = _outputBusArray[0].format;
    } else if (_inputBusArray.count > 0) {
        format = _inputBusArray[0].format;
    }

    if (format != nil) {
        _sampleRate = format.sampleRate;
        _sampleFormat = (format.commonFormat == AVAudioPCMFormatFloat64)
            ? BeamerAuSampleFormatFloat64
            : BeamerAuSampleFormatFloat32;
    } else {
        _sampleRate = kDefaultSampleRate;
        _sampleFormat = BeamerAuSampleFormatFloat32;
    }

    _maxFrames = self.maximumFramesToRender;
    if (_maxFrames == 0) {
        _maxFrames = kDefaultMaxFrames;
    }

    if (_inputBusArray.count > 0) {
        AVAudioFormat* inputFormat = _inputBusArray[0].format;
        _inputPCMBuffer = [[AVAudioPCMBuffer alloc] initWithPCMFormat:inputFormat
                                                       frameCapacity:_maxFrames];
        if (_inputPCMBuffer != nil) {
            _inputMutableABL = _inputPCMBuffer.mutableAudioBufferList;
        }
    }

    OSStatus result = beamer_au_allocate_render_resources(
        _rustInstance,
        _sampleRate,
        _maxFrames,
        _sampleFormat,
        &_busConfig
    );

    if (result != noErr) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:NSOSStatusErrorDomain
                                            code:result
                                        userInfo:@{NSLocalizedDescriptionKey: @"Failed to allocate Rust render resources"}];
        }
        [super deallocateRenderResources];
        return NO;
    }

    _resourcesAllocated = YES;
    return YES;
}

- (void)deallocateRenderResources {
    _inputMutableABL = NULL;
    _inputPCMBuffer = nil;

    if (_rustInstance != NULL && _resourcesAllocated) {
        beamer_au_deallocate_render_resources(_rustInstance);
        _resourcesAllocated = NO;
    }

    [super deallocateRenderResources];
}

- (AUInternalRenderBlock)internalRenderBlock {
    if (_cachedInternalRenderBlock != nil) {
        return _cachedInternalRenderBlock;
    }

    BeamerAuInstanceHandle rustInstance = _rustInstance;
    __unsafe_unretained typeof(self) blockSelf = self;

    _cachedInternalRenderBlock = ^AUAudioUnitStatus(
        AudioUnitRenderActionFlags* actionFlags,
        const AudioTimeStamp* timestamp,
        AUAudioFrameCount frameCount,
        NSInteger outputBusNumber,
        AudioBufferList* outputData,
        const AURenderEvent* realtimeEventListHead,
        AURenderPullInputBlock __unsafe_unretained pullInputBlock
    ) {
        if (rustInstance == NULL) {
            return kAudioUnitErr_Uninitialized;
        }

        AVAudioPCMBuffer* inputPCMBuffer = blockSelf->_inputPCMBuffer;
        AudioBufferList* inputMutableABL = blockSelf->_inputMutableABL;
        AUAudioFrameCount maxFrames = blockSelf->_maxFrames;

        AudioBufferList* inputData = NULL;
        if (inputPCMBuffer != nil && inputMutableABL != NULL && pullInputBlock != nil
            && frameCount <= maxFrames) {
            const AudioBufferList* originalABL = inputPCMBuffer.audioBufferList;
            UInt32 byteSize = frameCount * sizeof(float);

            inputMutableABL->mNumberBuffers = originalABL->mNumberBuffers;
            for (UInt32 i = 0; i < originalABL->mNumberBuffers; ++i) {
                inputMutableABL->mBuffers[i].mNumberChannels = originalABL->mBuffers[i].mNumberChannels;
                inputMutableABL->mBuffers[i].mData = originalABL->mBuffers[i].mData;
                inputMutableABL->mBuffers[i].mDataByteSize = byteSize;
            }

            AudioUnitRenderActionFlags pullFlags = 0;
            AUAudioUnitStatus pullStatus = pullInputBlock(&pullFlags, timestamp, frameCount, 0, inputMutableABL);
            if (pullStatus == noErr) {
                inputData = inputMutableABL;
            }
        }

        AUHostMusicalContextBlock musicalContext = blockSelf.musicalContextBlock;
        AUHostTransportStateBlock transportState = blockSelf.transportStateBlock;

        return beamer_au_render(
            rustInstance,
            actionFlags,
            timestamp,
            frameCount,
            outputBusNumber,
            outputData,
            realtimeEventListHead,
            pullInputBlock,
            inputData,
            musicalContext,
            transportState,
            NULL
        );
    };

    return _cachedInternalRenderBlock;
}

- (AUParameterTree*)parameterTree {
    if (_parameterTree == nil) {
        [self buildParameterTree];
    }
    return _parameterTree;
}

- (void)buildParameterTree {
    if (_rustInstance == NULL) {
        _parameterTree = nil;
        return;
    }

    uint32_t paramCount = beamer_au_get_parameter_count(_rustInstance);
    uint32_t groupCount = beamer_au_get_group_count(_rustInstance);

    if (paramCount == 0) {
        _parameterTree = [AUParameterTree createTreeWithChildren:@[]];
        return;
    }

    NSMutableArray<NSDictionary*>* allParams = [[NSMutableArray alloc] initWithCapacity:paramCount];
    for (uint32_t i = 0; i < paramCount; i++) {
        BeamerAuParameterInfo info;
        if (!beamer_au_get_parameter_info(_rustInstance, i, &info)) {
            continue;
        }

        NSString* identifier = [NSString stringWithFormat:@"param_%u", info.id];
        NSString* name = [NSString stringWithUTF8String:info.name];
        AudioUnitParameterUnit auUnit = (AudioUnitParameterUnit)info.unit_type;

        AudioUnitParameterOptions flags = kAudioUnitParameterFlag_IsReadable;
        if (!(info.flags & BeamerAuParameterFlagReadOnly)) {
            flags |= kAudioUnitParameterFlag_IsWritable;
        }

        NSArray<NSString*>* valueStrings = nil;
        uint32_t valueCount = beamer_au_get_parameter_value_count(_rustInstance, info.id);
        if (valueCount > 0) {
            NSMutableArray<NSString*>* strings = [[NSMutableArray alloc] initWithCapacity:valueCount];
            char stringBuffer[128];
            for (uint32_t vi = 0; vi < valueCount; vi++) {
                if (beamer_au_get_parameter_value_string(_rustInstance, info.id, vi, stringBuffer, sizeof(stringBuffer))) {
                    [strings addObject:[NSString stringWithUTF8String:stringBuffer]];
                }
            }
            if (strings.count == valueCount) {
                valueStrings = strings;
            }
        }

        float paramMin;
        float paramMax;
        float paramDefault;

        if (info.unit_type == kAudioUnitParameterUnit_Indexed) {
            paramMin = 0.0f;
            paramMax = (float)info.step_count;
            paramDefault = roundf(info.default_value * info.step_count);
        } else {
            paramMin = info.min_value;
            paramMax = info.max_value;
            paramDefault = info.default_value;
        }

        AUParameter* param = [AUParameterTree createParameterWithIdentifier:identifier
                                                                       name:name
                                                                    address:(AUParameterAddress)info.id
                                                                        min:paramMin
                                                                        max:paramMax
                                                                       unit:auUnit
                                                                   unitName:nil
                                                                      flags:flags
                                                               valueStrings:valueStrings
                                                        dependentParameters:nil];
        param.value = paramDefault;

        [allParams addObject:@{
            @"param": param,
            @"groupId": @(info.group_id)
        }];
    }

    NSMutableDictionary<NSNumber*, NSDictionary*>* groupInfoMap = [[NSMutableDictionary alloc] init];
    for (uint32_t i = 1; i < groupCount; i++) {
        BeamerAuGroupInfo ginfo;
        if (beamer_au_get_group_info(_rustInstance, i, &ginfo)) {
            NSString* gname = [NSString stringWithUTF8String:ginfo.name];
            groupInfoMap[@(ginfo.id)] = @{
                @"name": gname,
                @"parentId": @(ginfo.parent_id)
            };
        }
    }

    NSMutableDictionary<NSNumber*, AUParameterGroup*>* groupNodes = [[NSMutableDictionary alloc] init];
    NSMutableDictionary<NSNumber*, NSMutableArray<AUParameterNode*>*>* groupChildren = [[NSMutableDictionary alloc] init];

    groupChildren[@0] = [[NSMutableArray alloc] init];
    for (NSNumber* gid in groupInfoMap) {
        groupChildren[gid] = [[NSMutableArray alloc] init];
    }

    for (NSDictionary* pdict in allParams) {
        NSNumber* gid = pdict[@"groupId"];
        NSMutableArray* children = groupChildren[gid];
        if (children == nil) {
            children = groupChildren[@0];
        }
        [children addObject:pdict[@"param"]];
    }

    NSMutableSet<NSNumber*>* remaining = [NSMutableSet setWithArray:groupInfoMap.allKeys];
    while (remaining.count > 0) {
        BOOL madeProgress = NO;
        for (NSNumber* gid in [remaining copy]) {
            NSDictionary* ginfo = groupInfoMap[gid];
            NSNumber* parentId = ginfo[@"parentId"];

            if ([parentId intValue] == 0 || groupNodes[parentId] != nil) {
                NSString* gname = ginfo[@"name"];
                NSString* gidentifier = [NSString stringWithFormat:@"group_%d", [gid intValue]];

                AUParameterGroup* group = [AUParameterTree createGroupWithIdentifier:gidentifier
                                                                                name:gname
                                                                            children:groupChildren[gid]];
                groupNodes[gid] = group;
                [groupChildren[parentId] addObject:group];

                [remaining removeObject:gid];
                madeProgress = YES;
            }
        }

        if (!madeProgress && remaining.count > 0) {
            for (NSNumber* gid in remaining) {
                NSDictionary* ginfo = groupInfoMap[gid];
                NSString* gname = ginfo[@"name"];
                NSString* gidentifier = [NSString stringWithFormat:@"group_%d", [gid intValue]];

                AUParameterGroup* group = [AUParameterTree createGroupWithIdentifier:gidentifier
                                                                                name:gname
                                                                            children:groupChildren[gid]];
                groupNodes[gid] = group;
                [groupChildren[@0] addObject:group];
            }
            break;
        }
    }

    _parameterTree = [AUParameterTree createTreeWithChildren:groupChildren[@0]];
    [self setupParameterCallbacks];
}

- (void)setupParameterCallbacks {
    if (_parameterTree == nil || _rustInstance == NULL) {
        return;
    }

    __weak typeof(self) weakSelf = self;

    _parameterTree.implementorValueProvider = ^AUValue(AUParameter* param) {
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil) {
            return 0.0f;
        }

        [strongSelf->_instanceLock lock];
        AUValue result = 0.0f;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {
            result = beamer_au_get_parameter_value_au(strongSelf->_rustInstance, (uint32_t)param.address);
        }
        [strongSelf->_instanceLock unlock];
        return result;
    };

    _parameterTree.implementorValueObserver = ^(AUParameter* param, AUValue value) {
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil) {
            return;
        }

        [strongSelf->_instanceLock lock];
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {
            beamer_au_set_parameter_value_au(strongSelf->_rustInstance, (uint32_t)param.address, value);
        }
        [strongSelf->_instanceLock unlock];
    };

    _parameterTree.implementorStringFromValueCallback = ^NSString* _Nonnull(AUParameter* param, const AUValue* value) {
        __strong typeof(self) strongSelf = weakSelf;
        AUValue displayValue = (value != NULL) ? *value : param.value;

        if (strongSelf == nil) {
            return [NSString stringWithFormat:@"%.2f", displayValue];
        }

        [strongSelf->_instanceLock lock];
        NSString* result = nil;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {
            float normalizedValue = 0.0f;
            if (param.unit == kAudioUnitParameterUnit_Indexed && param.maxValue > 0) {
                normalizedValue = displayValue / param.maxValue;
            } else if (param.maxValue > param.minValue) {
                normalizedValue = (displayValue - param.minValue) / (param.maxValue - param.minValue);
            }
            char buffer[128];
            uint32_t written = beamer_au_format_parameter_value(
                strongSelf->_rustInstance,
                (uint32_t)param.address,
                normalizedValue,
                buffer,
                sizeof(buffer)
            );
            if (written > 0) {
                result = [NSString stringWithUTF8String:buffer];
            }
        }
        [strongSelf->_instanceLock unlock];

        return (result != nil) ? result : [NSString stringWithFormat:@"%.2f", displayValue];
    };

    _parameterTree.implementorValueFromStringCallback = ^AUValue(AUParameter* param, NSString* string) {
        __strong typeof(self) strongSelf = weakSelf;
        if (strongSelf == nil || string == nil) {
            return param.value;
        }

        [strongSelf->_instanceLock lock];
        AUValue result = param.value;
        if (strongSelf->_instanceValid && strongSelf->_rustInstance != NULL) {
            float parsedNormalized = 0.0f;
            if (beamer_au_parse_parameter_value(strongSelf->_rustInstance, (uint32_t)param.address, string.UTF8String, &parsedNormalized)) {
                if (param.unit == kAudioUnitParameterUnit_Indexed && param.maxValue > 0) {
                    result = roundf(parsedNormalized * param.maxValue);
                } else {
                    result = param.minValue + parsedNormalized * (param.maxValue - param.minValue);
                }
            }
        }
        [strongSelf->_instanceLock unlock];
        return result;
    };
}

- (NSDictionary<NSString*, id>*)fullState {
    NSMutableDictionary* state = [[super fullState] mutableCopy];
    if (state == nil) {
        state = [[NSMutableDictionary alloc] init];
    }

    if (_rustInstance != NULL) {
        uint32_t stateSize = beamer_au_get_state_size(_rustInstance);
        if (stateSize > 0) {
            uint8_t* buffer = (uint8_t*)malloc(stateSize);
            if (buffer != NULL) {
                uint32_t written = beamer_au_get_state(_rustInstance, buffer, stateSize);
                if (written > 0) {
                    NSData* stateData = [NSData dataWithBytes:buffer length:written];
                    state[@"beamerState"] = stateData;
                }
                free(buffer);
            }
        }
    }

    return state;
}

- (void)setFullState:(NSDictionary<NSString*, id>*)fullState {
    [super setFullState:fullState];

    if (_rustInstance != NULL && fullState != nil) {
        NSData* stateData = fullState[@"beamerState"];
        if (stateData != nil && stateData.length > 0) {
            OSStatus status = beamer_au_set_state(_rustInstance, stateData.bytes, (uint32_t)stateData.length);

            if (status != noErr) {
                return;
            }

            if (_parameterTree != nil) {
                for (AUParameter* param in _parameterTree.allParameters) {
                    AUValue newValue = beamer_au_get_parameter_value_au(_rustInstance, (uint32_t)param.address);
                    [param setValue:newValue originator:nil];
                }
            }
        }
    }
}

- (AUAudioUnitPreset*)currentPreset {
    return _currentPreset;
}

- (void)setCurrentPreset:(AUAudioUnitPreset*)currentPreset {
    if (currentPreset == nil) {
        _currentPreset = nil;
        return;
    }
    _currentPreset = currentPreset;

    if (currentPreset.number >= 0) {
        [self applyFactoryPreset:(int)currentPreset.number];
    }
}

- (void)applyFactoryPreset:(int)presetNumber {
    if (_rustInstance == NULL) {
        return;
    }

    if (!beamer_au_apply_preset(_rustInstance, (uint32_t)presetNumber)) {
        return;
    }

    if (_parameterTree != nil) {
        for (AUParameter* param in _parameterTree.allParameters) {
            AUValue newValue = beamer_au_get_parameter_value_au(_rustInstance, (uint32_t)param.address);
            [param setValue:newValue originator:nil];
        }
    }
}

- (NSArray<AUAudioUnitPreset*>*)factoryPresets {
    if (_factoryPresets == nil && _rustInstance != NULL) {
        uint32_t presetCount = beamer_au_get_preset_count(_rustInstance);

        if (presetCount > 0) {
            NSMutableArray<AUAudioUnitPreset*>* presets = [[NSMutableArray alloc] initWithCapacity:presetCount];

            for (uint32_t i = 0; i < presetCount; i++) {
                BeamerAuPresetInfo info;
                memset(&info, 0, sizeof(info));

                if (beamer_au_get_preset_info(_rustInstance, i, &info)) {
                    AUAudioUnitPreset* preset = [[AUAudioUnitPreset alloc] init];
                    preset.number = (NSInteger)info.number;
                    preset.name = [NSString stringWithUTF8String:info.name];
                    [presets addObject:preset];
                }
            }

            _factoryPresets = [presets copy];
        }
    }
    return _factoryPresets;
}

- (NSTimeInterval)latency {
    if (_rustInstance == NULL || _sampleRate <= 0.0) {
        return 0.0;
    }
    uint32_t latencySamples = beamer_au_get_latency_samples(_rustInstance);
    return (NSTimeInterval)latencySamples / _sampleRate;
}

- (NSTimeInterval)tailTime {
    if (_rustInstance == NULL || _sampleRate <= 0.0) {
        return 0.0;
    }
    uint32_t tailSamples = beamer_au_get_tail_samples(_rustInstance);
    if (tailSamples == UINT32_MAX) {
        return INFINITY;
    }
    return (NSTimeInterval)tailSamples / _sampleRate;
}

- (BOOL)supportsMPE {
    return NO;
}

- (NSArray<NSString*>*)MIDIOutputNames {
    return @[];
}

- (BOOL)supportsUserPresets {
    return YES;
}

- (NSArray<NSNumber*>*)channelCapabilities {
    BeamerAuChannelCapabilities caps;
    if (!beamer_au_get_channel_capabilities(_rustInstance, &caps)) {
        return nil;
    }

    if (caps.count == 0) {
        return nil;
    }

    NSMutableArray<NSNumber*>* result = [[NSMutableArray alloc] initWithCapacity:caps.count * 2];
    for (uint32_t i = 0; i < caps.count; i++) {
        [result addObject:@(caps.capabilities[i].input_channels)];
        [result addObject:@(caps.capabilities[i].output_channels)];
    }
    return result;
}

- (void)reset {
    if (_rustInstance != NULL) {
        beamer_au_reset(_rustInstance);
    }
}

- (BOOL)canProcessInPlace {
    return NO;
}

// =============================================================================
// MARK: - View Configuration
// =============================================================================

// Only accept zero-sized view configurations. Logic and GarageBand offer a
// {0, 0} entry meaning "use the view controller's preferredContentSize".
// Accepting only that entry makes the host defer to our configured GUI
// size instead of picking an oversized screen-resolution layout.
- (NSIndexSet*)supportedViewConfigurations:(NSArray<AUAudioUnitViewConfiguration*>*)availableViewConfigurations
    API_AVAILABLE(macos(10.13), ios(11)) {
    NSMutableIndexSet* indices = [[NSMutableIndexSet alloc] init];
    for (NSUInteger i = 0; i < availableViewConfigurations.count; i++) {
        AUAudioUnitViewConfiguration* config = availableViewConfigurations[i];
        if (config.width + config.height == 0) {
            [indices addIndex:i];
        }
    }
    return indices;
}

// =============================================================================
// MARK: - GUI / WebView
// =============================================================================

// Hosts call this method on the AUAudioUnit to get a view controller for the
// plugin UI. This is the primary UI path for hosts like Reaper that use the
// AUAudioUnit API directly. For hosts that check the extension's principal
// class (Logic Pro), the AUViewController extension in auv3_extension_gui.m
// provides the UI independently.
- (void)requestViewControllerWithCompletionHandler:
    (void (^)(NSViewController* _Nullable))completionHandler {
    if (!beamer_au_has_gui(_rustInstance)) {
        completionHandler(nil);
        return;
    }

    // Destroy previous WebView if host calls this method again
    if (_webviewHandle != NULL) {
        beamer_webview_destroy(_webviewHandle);
        _webviewHandle = NULL;
    }

    const char* html = beamer_au_get_gui_html(_rustInstance);
    if (html == NULL) {
        completionHandler(nil);
        return;
    }

    uint32_t width = 0, height = 0;
    beamer_au_get_gui_size(_rustInstance, &width, &height);

    NSViewController* vc = [[NSViewController alloc] init];
    NSView* container = [[NSView alloc]
        initWithFrame:NSMakeRect(0, 0, width, height)];
    vc.view = container;
    vc.preferredContentSize = NSMakeSize(width, height);

#ifdef DEBUG
    bool devTools = true;
#else
    bool devTools = false;
#endif
    void* webviewHandle = beamer_webview_create(
        (__bridge void*)container, html, devTools);
    if (webviewHandle == NULL) {
        completionHandler(nil);
        return;
    }

    _webviewHandle = webviewHandle;
    completionHandler(vc);
}

@end
