# Phase 2B: Resource Loading

Multi-file web UIs, custom URL scheme serving and dev server hot reload.

## Overview

Phase 2A loads a single HTML string via `loadHTMLString:baseURL:`. This
works for basic demos but breaks down with real UIs: relative paths don't
resolve (no base URL), `fetch()` doesn't work for local resources and
framework build output (multiple JS/CSS files) can't be served.

Phase 2B replaces `loadHTMLString` with a custom URL scheme handler that
serves embedded assets. This is the same architecture used by Tauri (via
wry) for serving web content in native applications.

Phase 2B targets macOS only. Windows patterns are noted for reference
where relevant but implementation is deferred (the Windows WebView
backend is still a stub from Phase 2A).

## Resource Loading Strategy

### Production: Custom URL Scheme

All webview assets (HTML, JS, CSS, images, fonts) are embedded into the
plugin binary at compile time and served at runtime through a custom URL
scheme:

```
beamer://localhost/index.html
beamer://localhost/assets/index-abc123.js
beamer://localhost/assets/style-def456.css
```

**How it works:**

1. The `#[beamer::export]` proc macro scans the webview directory at
   compile time
2. Each file is embedded via `include_bytes!()` into a static asset
   table
3. At runtime, a `WKURLSchemeHandler` (macOS) or `WebResourceRequested`
   handler (Windows) intercepts requests to `beamer://`
4. The handler looks up the requested path in the asset table, detects
   the MIME type and returns the file contents
5. The WebView navigates to `beamer://localhost/index.html`

Relative paths, `fetch()`, source maps and lazy-loaded modules all work
naturally because the WebView sees a proper origin with standard URL
resolution.

### Development: Dev Server Mode

During development, the WebView loads from a local dev server URL instead
of embedded assets. This enables hot module replacement (HMR) for instant
feedback on web changes without rebuilding the Rust plugin.

Activated via environment variable:

```bash
BEAMER_DEV_URL=http://localhost:5173 cargo build -p my-plugin
```

The `#[beamer::export]` macro checks this at compile time and generates
config with a URL source instead of embedded assets.

### Reference: Tauri

Tauri uses the same pattern via its `wry` crate: assets are compiled
into the binary and served through a custom URL scheme
(`asset://localhost/`). On macOS this uses `WKURLSchemeHandler`, on
Windows `WebResourceRequested`. Beamer follows the same approach with
the same `objc2` bindings that wry uses.

## Asset Embedding

### EmbeddedAsset Type

```rust
// beamer-core/src/assets.rs

/// A single file embedded at compile time.
pub struct EmbeddedAsset {
    pub path: &'static str,
    pub data: &'static [u8],
}

/// Collection of embedded web assets.
pub struct EmbeddedAssets {
    assets: &'static [EmbeddedAsset],
}

impl EmbeddedAssets {
    pub const fn new(assets: &'static [EmbeddedAsset]) -> Self {
        Self { assets }
    }

    /// Look up a file by path (e.g. "index.html", "assets/style.css").
    pub fn get(&self, path: &str) -> Option<&'static [u8]> {
        self.assets.iter()
            .find(|a| a.path == path)
            .map(|a| a.data)
    }
}
```

No third-party crate needed. The proc macro generates `include_bytes!()`
calls and the types are defined in `beamer-core` (to avoid a circular
dependency, since `beamer-webview` depends on `beamer-core`).
`beamer-webview` re-exports them for convenience.

### Proc Macro Directory Scanning

The `#[beamer::export]` macro scans the webview directory at expansion
time and generates an asset table:

```rust
// Generated by #[beamer::export] for a framework plugin
pub static WEBVIEW_ASSETS: beamer_webview::EmbeddedAssets =
    beamer_webview::EmbeddedAssets::new(&[
        beamer_webview::EmbeddedAsset {
            path: "index.html",
            data: include_bytes!(concat!(
                env!("CARGO_MANIFEST_DIR"), "/webview/dist/index.html"
            )),
        },
        beamer_webview::EmbeddedAsset {
            path: "assets/index-a1b2c3.js",
            data: include_bytes!(concat!(
                env!("CARGO_MANIFEST_DIR"), "/webview/dist/assets/index-a1b2c3.js"
            )),
        },
        beamer_webview::EmbeddedAsset {
            path: "assets/style-d4e5f6.css",
            data: include_bytes!(concat!(
                env!("CARGO_MANIFEST_DIR"), "/webview/dist/assets/style-d4e5f6.css"
            )),
        },
    ]);
```

The macro walks the directory tree recursively, collecting all files with
their relative paths. Each file becomes an `include_bytes!()` entry.
Rust's build system tracks `include_bytes!()` paths, so changes to
existing files trigger recompilation automatically.

**Exclusions:** The directory scan skips:

- Dotfiles and dot-directories (`.DS_Store`, `.gitkeep`, etc.)
- `node_modules/`
- Source maps (`*.map`) - not needed in production; use dev server mode
  for debugging

### Detection Rules

```rust
let dev_url = std::env::var("BEAMER_DEV_URL").ok();
let has_package_json = Path::new(manifest_dir)
    .join("webview/package.json").exists();
let dist_dir = Path::new(manifest_dir).join("webview/dist");
let webview_dir = Path::new(manifest_dir).join("webview");
```

| Condition | Behavior |
|-----------|----------|
| `BEAMER_DEV_URL` set | Load from URL (any project type) |
| `package.json` + `dist/` exists | Embed all files from `webview/dist/` |
| `package.json` without `dist/` | No assets (build not run yet) |
| `webview/` exists (no `package.json`) | Embed all files from `webview/` |
| No `webview/` directory | No GUI |

**Note on caching:** The proc macro scans the directory at expansion
time. After running `bun run build` for the first time, you may need to
touch a `.rs` file to trigger recompilation. Adding or removing files
also requires recompilation. `cargo xtask bundle` avoids this by always
running the web build before `cargo build`. Changes to existing file
contents are tracked automatically by `include_bytes!()`.

## Custom URL Scheme Handler

### macOS (`WKURLSchemeHandler`)

Define a custom ObjC class using `objc2`'s `define_class!` that
implements the `WKURLSchemeHandler` protocol:

```rust
// beamer-webview/src/platform/macos_scheme.rs

use objc2::define_class;
use objc2_web_kit::{WKURLSchemeHandler, WKURLSchemeTask, WKWebView};

define_class! {
    #[unsafe(super(NSObject))]
    pub struct BeamerSchemeHandler;

    unsafe impl WKURLSchemeHandler for BeamerSchemeHandler {
        #[unsafe(method(webView:startURLSchemeTask:))]
        fn start_scheme_task(
            &self,
            _webview: &WKWebView,
            task: &ProtocolObject<dyn WKURLSchemeTask>,
        ) {
            // 1. Extract path from request URL
            //    e.g. beamer://localhost/assets/style.css -> "assets/style.css"
            // 2. Look up in global asset table
            // 3. Detect MIME type from file extension
            // 4. Send NSURLResponse + NSData via task
            // 5. Call didFinish
        }

        #[unsafe(method(webView:stopURLSchemeTask:))]
        fn stop_scheme_task(
            &self,
            _webview: &WKWebView,
            _task: &ProtocolObject<dyn WKURLSchemeTask>,
        ) {
            // No-op for synchronous responses
        }
    }
}
```

**Registration** in `MacosWebView::attach_to_parent`:

```rust
let handler = BeamerSchemeHandler::new();
unsafe {
    wk_config.setURLSchemeHandler_forURLScheme(
        &handler,
        &NSString::from_str("beamer"),
    );
};
```

**Navigation** after attaching:

```rust
let url = NSString::from_str("beamer://localhost/index.html");
let nsurl = unsafe { NSURL::URLWithString(&url) }.unwrap();
let request = unsafe { NSURLRequest::requestWithURL(&nsurl) };
unsafe { webview.loadRequest(&request) };
```

New `objc2-web-kit` features needed: `WKURLSchemeHandler`,
`WKURLSchemeTask`. New `objc2-foundation` features needed: `NSURL`,
`NSURLRequest`, `NSURLResponse`, `NSHTTPURLResponse`, `NSData`.

### Windows (future)

The equivalent on Windows is WebView2's `WebResourceRequested` event or
`SetVirtualHostNameToFolderMapping`. Implementation deferred until the
Windows WebView backend is built out.

### Global Asset Registration

Since each plugin is its own dylib (one plugin per binary), a global
static is the simplest way for the scheme handler to access embedded
assets:

```rust
// beamer-core/src/assets.rs

use std::sync::OnceLock;

static GLOBAL_ASSETS: OnceLock<&'static EmbeddedAssets> = OnceLock::new();

/// Register the embedded assets for the scheme handler.
/// Called once during plugin initialization.
pub fn register_assets(assets: &'static EmbeddedAssets) {
    GLOBAL_ASSETS.set(assets).ok();
}

/// Look up a file by path. Used by the scheme handler.
pub fn get_asset(path: &str) -> Option<&'static [u8]> {
    GLOBAL_ASSETS.get()?.get(path)
}
```

The proc macro generates a call to `register_assets()` during plugin
initialization (in the `#[beamer::export]` init block).

### MIME Type Detection

Built-in map covering standard web asset types. No external crate
needed:

```rust
fn mime_for_extension(path: &str) -> &'static str {
    match path.rsplit('.').next().unwrap_or("") {
        "html" | "htm" => "text/html",
        "css" => "text/css",
        "js" | "mjs" => "text/javascript",
        "json" => "application/json",
        "png" => "image/png",
        "jpg" | "jpeg" => "image/jpeg",
        "svg" => "image/svg+xml",
        "webp" => "image/webp",
        "gif" => "image/gif",
        "ico" => "image/x-icon",
        "woff" => "font/woff",
        "woff2" => "font/woff2",
        "ttf" => "font/ttf",
        "otf" => "font/otf",
        "wasm" => "application/wasm",
        "map" => "application/json",
        _ => "application/octet-stream",
    }
}
```

## Changes

### WebViewConfig

Replace the HTML string with an asset/URL source:

```rust
// beamer-webview/src/lib.rs

pub enum WebViewSource<'a> {
    /// Serve embedded assets via custom URL scheme.
    Assets(&'a EmbeddedAssets),
    /// Navigate to a URL (dev server).
    Url(&'a str),
}

pub struct WebViewConfig<'a> {
    /// Content source.
    pub source: WebViewSource<'a>,
    /// Whether to enable developer tools.
    pub dev_tools: bool,
}
```

### beamer-core Config

Replace `gui_html` with `gui_assets` and add `gui_url`:

```rust
// beamer-core/src/config.rs

/// Embedded web assets for the GUI. Set by the proc macro from the
/// webview directory contents.
pub gui_assets: Option<&'static EmbeddedAssets>,

/// Dev server URL. Takes priority over `gui_assets` when set.
pub gui_url: Option<&'static str>,
```

Builder methods:

```rust
pub const fn with_gui_assets(mut self, assets: &'static EmbeddedAssets) -> Self {
    self.gui_assets = Some(assets);
    self.has_gui = true;
    self
}

pub const fn with_gui_url(mut self, url: &'static str) -> Self {
    self.gui_url = Some(url);
    self.has_gui = true;
    self
}
```

### C-ABI Changes

The `beamer_webview_create` signature changes. The scheme handler
accesses assets through the global registration, so the create function
no longer takes an HTML parameter:

```rust
// beamer-webview/src/ffi.rs

/// Create a WebView serving embedded assets via custom scheme.
/// Assets must be registered via register_assets() before calling this.
/// Returns an opaque handle, or null on failure.
#[no_mangle]
pub extern "C" fn beamer_webview_create(
    parent: *mut c_void,
    dev_tools: bool,
) -> *mut c_void;

/// Create a WebView that loads from a URL (dev server mode).
/// Returns an opaque handle, or null on failure.
#[no_mangle]
pub extern "C" fn beamer_webview_create_url(
    parent: *mut c_void,
    url: *const c_char,
    dev_tools: bool,
) -> *mut c_void;
```

The AU bridge simplifies - `beamer_au_get_gui_html` is removed:

```rust
// beamer-au/src/bridge.rs

/// Whether the plugin has a custom GUI.
#[no_mangle]
pub extern "C" fn beamer_au_has_gui(instance: BeamerAuInstanceHandle) -> bool;

/// Get the dev server URL. Returns NULL in production mode.
#[no_mangle]
pub extern "C" fn beamer_au_get_gui_url(
    instance: BeamerAuInstanceHandle,
) -> *const c_char;

/// Get the initial GUI size.
#[no_mangle]
pub extern "C" fn beamer_au_get_gui_size(
    instance: BeamerAuInstanceHandle,
    width: *mut u32,
    height: *mut u32,
);
```

### AU Wrapper Changes

Both AUv3 and AUv2 wrappers check for dev URL, then fall back to
embedded assets:

```objc
if (!beamer_au_has_gui(_rustInstance)) {
    completionHandler(nil);
    return;
}

const char* devUrl = beamer_au_get_gui_url(_rustInstance);
void* webviewHandle;

if (devUrl != NULL) {
    webviewHandle = beamer_webview_create_url(
        (__bridge void*)container, devUrl, devTools);
} else {
    // Assets already registered globally during plugin init
    webviewHandle = beamer_webview_create(
        (__bridge void*)container, devTools);
}
```

### VST3 Changes

Update `createView()` in `beamer-vst3/src/processor.rs`:

```rust
let source = if let Some(url) = self.config.gui_url {
    beamer_webview::WebViewSource::Url(url)
} else if let Some(assets) = self.config.gui_assets {
    beamer_webview::WebViewSource::Assets(assets)
} else {
    return std::ptr::null_mut();
};

let config = WebViewConfig {
    source,
    dev_tools: cfg!(debug_assertions),
};
```

## xtask Build Integration

### Web Build Orchestration

`cargo xtask bundle` gains a webview build step:

```rust
// xtask/src/build.rs

fn build_webview(package_dir: &Path) -> Result<()> {
    let webview_dir = package_dir.join("webview");
    let package_json = webview_dir.join("package.json");

    if !package_json.exists() {
        return Ok(()); // Plain HTML or no webview
    }

    let (cmd, install_args, run_args) = detect_package_manager(&webview_dir);

    // Install dependencies
    run_command(&cmd, &install_args, &webview_dir)?;

    // Run build
    run_command(&cmd, &run_args, &webview_dir)?;

    // Verify output
    let dist_dir = webview_dir.join("dist");
    if !dist_dir.join("index.html").exists() {
        bail!("webview build did not produce dist/index.html");
    }

    Ok(())
}
```

### Package Manager Detection

Detect from lockfile, default to bun:

```rust
fn detect_package_manager(webview_dir: &Path)
    -> (&'static str, Vec<&'static str>, Vec<&'static str>)
{
    if webview_dir.join("pnpm-lock.yaml").exists() {
        ("pnpm", vec!["install"], vec!["run", "build"])
    } else if webview_dir.join("yarn.lock").exists() {
        ("yarn", vec!["install"], vec!["run", "build"])
    } else if webview_dir.join("package-lock.json").exists() {
        ("npm", vec!["install"], vec!["run", "build"])
    } else {
        ("bun", vec!["install"], vec!["run", "build"])
    }
}
```

### Bundle Flow

Updated `cargo xtask bundle` sequence:

1. Build webview assets (if `webview/package.json` exists)
2. Build Rust binary (`cargo build --release`)
3. Create plugin bundle (`.vst3`, `.component`, etc.)

The web build runs first so that `webview/dist/` exists when the proc
macro scans the directory during step 2.

## Vite Configuration

Standard Vite config works out of the box. No special plugins needed:

```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [react(), tailwindcss()],
  build: {
    outDir: 'dist',
  },
})
```

The custom URL scheme serves all output files (HTML, JS, CSS, images)
with proper MIME types and relative path resolution. This is one of the
main advantages over the single-file approach - standard Vite output
works without modification.

## Development Workflow

### Plain HTML Plugin

No build step needed. Edit `webview/index.html`, rebuild the Rust plugin:

```bash
cargo build -p my-plugin
```

### Framework Plugin (Hot Reload)

Terminal 1 - start dev server:

```bash
cd examples/my-plugin/webview
bun dev
```

Terminal 2 - build plugin with dev server URL:

```bash
BEAMER_DEV_URL=http://localhost:5173 cargo build -p my-plugin
```

Load the plugin in a host. Web changes are reflected instantly via HMR.
Rust changes require a rebuild.

### Framework Plugin (Production)

```bash
cargo xtask bundle my-plugin
```

This runs the full pipeline: web build, Rust build, plugin bundling.

## Plugin Directory Convention

**Plain HTML (no build step):**

```
examples/gain/
├── Cargo.toml
├── Config.toml
├── src/
│   └── lib.rs
└── webview/
    └── index.html
```

**Framework-based (React, Svelte, etc.):**

```
examples/equalizer/
├── Cargo.toml
├── Config.toml
├── src/
│   └── lib.rs
└── webview/
    ├── package.json
    ├── vite.config.ts
    ├── index.html          ← Vite entry point (dev server)
    ├── src/
    │   └── App.tsx
    └── dist/               ← Build output (gitignored)
        ├── index.html
        └── assets/
            ├── index-a1b2c3.js
            └── style-d4e5f6.css
```

## Example Plugin

A framework-based example using React:

```rust
// examples/webview-react/src/lib.rs

#[beamer::export]
#[derive(Default, HasParameters)]
pub struct WebViewReactDescriptor {
    #[parameters]
    pub parameters: WebViewReactParameters,
}
```

```toml
# examples/webview-react/Config.toml
name = "Beamer WebView React Demo"
category = "effect"
has_gui = true
gui_size = [600, 400]
```

```json
// examples/webview-react/webview/package.json
{
  "private": true,
  "scripts": {
    "dev": "bunx --bun vite",
    "build": "bunx --bun vite build"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwindcss": "^4.0.0",
    "vite": "^6.0.0"
  }
}
```

## Tasks

### beamer-webview changes
- [ ] Add MIME type detection
- [ ] Implement `BeamerSchemeHandler` (`WKURLSchemeHandler`) via
  `define_class!`
- [ ] Register scheme handler in `MacosWebView::attach_to_parent`
- [ ] Replace `loadHTMLString` with `loadRequest` to `beamer://localhost/`
- [ ] Add `beamer_webview_create_url` C-ABI export for dev server mode
- [ ] Update `beamer_webview_create` C-ABI (remove `html` parameter)
- [ ] Add `objc2-web-kit` features: `WKURLSchemeHandler`,
  `WKURLSchemeTask`
- [ ] Add `objc2-foundation` features: `NSURL`, `NSURLRequest`,
  `NSURLResponse`, `NSHTTPURLResponse`, `NSData`

### beamer-core changes
- [ ] Add `EmbeddedAsset`, `EmbeddedAssets` types and global registration
- [ ] Replace `gui_html` with `gui_assets: Option<&'static EmbeddedAssets>`
- [ ] Add `gui_url: Option<&'static str>` for dev server mode
- [ ] Add `with_gui_assets()` and `with_gui_url()` builder methods

### beamer-macros changes
- [ ] Add directory scanning to `#[beamer::export]` (walk webview dir,
  generate `include_bytes!()` per file)
- [ ] Generate `EmbeddedAssets` static and `register_assets()` call
- [ ] Check `BEAMER_DEV_URL` env var for dev server mode
- [ ] Detection logic: `dist/` for framework projects, `webview/` for
  plain HTML

### beamer-vst3 changes
- [ ] Update `createView()` to use `WebViewSource::Assets` /
  `WebViewSource::Url`

### beamer-au changes
- [ ] Remove `beamer_au_get_gui_html`, add `beamer_au_get_gui_url`
- [ ] Update AUv3 wrapper: use `beamer_webview_create` (no html param)
  or `beamer_webview_create_url`
- [ ] Update AUv2 wrapper: same

### xtask changes
- [ ] Add `build_webview()` function with package manager detection
- [ ] Integrate web build step into `cargo xtask bundle` flow
- [ ] Add build output verification

### Example & testing
- [ ] Update `webview-demo` example to use custom URL scheme (plain HTML)
- [ ] Create framework-based example plugin (React)
- [ ] Verify hot reload with dev server
- [ ] Verify production build via `cargo xtask bundle`
- [ ] Verify in a VST3 host
- [ ] Verify in an AU host

## References

- [WKURLSchemeHandler](https://developer.apple.com/documentation/webkit/wkurlschemehandler) -
  Apple custom URL scheme handler protocol
- [WKURLSchemeTask](https://developer.apple.com/documentation/webkit/wkurlschemetask) -
  Apple URL scheme task protocol
- [Tauri wry custom protocols](https://github.com/tauri-apps/wry) -
  reference implementation using objc2 + WKURLSchemeHandler
- [objc2 define_class!](https://docs.rs/objc2/latest/objc2/macro.define_class.html) -
  defining ObjC classes in Rust
- [objc2-web-kit](https://docs.rs/objc2-web-kit/) -
  WebKit bindings including WKURLSchemeHandler
- [Vite](https://vitejs.dev/) - frontend build tool
- [WebView2 WebResourceRequested](https://learn.microsoft.com/en-us/microsoft-edge/webview2/reference/win32/icorewebview2#add_webresourcerequested) -
  Windows resource interception
